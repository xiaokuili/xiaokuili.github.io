[{"content":"","date":"30 August 2023","permalink":"/tags/leetcode/","section":"Tags","summary":"","title":"leetcode"},{"content":"","date":"30 August 2023","permalink":"/series/leetcode/","section":"Series","summary":"","title":"Leetcode"},{"content":"十三四岁的夏天，在路上捡到一支真枪。那时年少无知，天不怕地不怕，扣下扳机。\n没有人死，也没有人受伤。认为自己开了空枪。\n后来三十岁，走在路上听到背后有隐隐约约的风声。\n停下来转过身去，子弹正中眉心。\n后来，在那明媚的阳光中传来一声枪响。\n","date":"30 August 2023","permalink":"/leetcode-tour/","section":"LeetCode Tour","summary":"十三四岁的夏天，在路上捡到一支真枪。那时年少无知，天不怕地不怕，扣下扳机。\n没有人死，也没有人受伤。认为自己开了空枪。\n后来三十岁，走在路上听到背后有隐隐约约的风声。\n停下来转过身去，子弹正中眉心。\n后来，在那明媚的阳光中传来一声枪响。","title":"LeetCode Tour"},{"content":"","date":"30 August 2023","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"Blowfish has full support for Hugo taxonomies and will adapt to any taxonomy set up. Taxonomy listings like this one also support custom content to be displayed above the list of terms.\nThis area could be used to add some extra decriptive text to each taxonomy. Check out the advanced tag below to see how to take this concept even further.\n","date":"30 August 2023","permalink":"/tags/","section":"Tags","summary":"Blowfish has full support for Hugo taxonomies and will adapt to any taxonomy set up. Taxonomy listings like this one also support custom content to be displayed above the list of terms.","title":"Tags"},{"content":"If I don\u0026rsquo;t know why I should do something, I\u0026rsquo;ll never start or find it.\n魔法游戏 点击 \u0026orarr; 无所谓，不在乎，不选择，爱谁谁。最后，爱谁谁\n","date":"30 August 2023","permalink":"/","section":"Welcome to WithME! 🎉","summary":"If I don\u0026rsquo;t know why I should do something, I\u0026rsquo;ll never start or find it.\n魔法游戏 点击 \u0026orarr; 无所谓，不在乎，不选择，爱谁谁。最后，爱谁谁","title":"Welcome to WithME! 🎉"},{"content":"玩游戏时会上瘾的。如果玩过游戏的话。\nleetcode也是游戏，而且不过是一个普通高中智商的游戏，但是必须通过新手村。\n假如一个rpg游戏，新手村会告诉你，游戏的大致规则，装备的等级玩法，什么时候去刷什么怪物，用什么技能，出什么装备等\nleetcode新手村，同样会告诉，知识点的等级，什么时候去做什么样的题目，用什么模版等。只要过了新手村，就知道怎么玩leetcode。\n但是新手村很难过，除非上瘾\n触发 # 你知道吗？微信有一个功能，你喜欢的女孩的提示音，和其他人的不同\n微信当然没有这个功能，是你给微信添加了这个功能，当提示音响起的时候，你会迫不及待的去打开手机，打开微信。你心甘情愿的被这个声音控制，然后执行后续一些列动作\n你真的会骗自己吗？\n对工作不稳定的恐惧。 对海岛，旅居，新鲜事的向往 对年收入100w的生活的好奇 之前带一个人一起刷题，所以责任感让我必须每天投入 流程 # 心流\n我最爱的一个例子\n21. Merge Two Sorted Lists\n这是一道简单题，需要合并两个增序链表，当做完这道题后，会掌握一个merge(l1,l2)的写法，当然现在不需要知道。\n23. Merge k Sorted Lists\n这是一道困难题，合并[l1,l2,l3,l4] ,应该如何做呢。下面是伪代码\nstep1: merge(l1,l2) -\u0026gt; [l3,l4,nl1] # 合并l1,l2，得到[l3,l4,nl1] step2: merge(l3,l4) -\u0026gt; [nl1, nl2] step3: merge(nl1, nl2) -\u0026gt; [nl3] # 直到列表中只剩下一个元素 # 可以将列表中元素当作面团，每次那两个揉成一个，直到只剩下一个 while len(arr) \u0026gt; 1: arr.append(merge(arr[0],arr[1])) return arr[0] 难吗？while会把，merge之前简单题掌握了。\n每一步都尽可能简单，同时又有收获，让注意力尽可能在当下，心无旁骛，不被干扰，你没空想，我做回了我女朋友要怎么奖励我，我不会怎么找工作，做题就是整个灵魂在做题。\n当然，上面一段肯定是吹牛逼的\n随机性奖励 # 代码能力提高。递归锻炼抽象，dp锻炼逻辑 youtube的100个观察。我高兴了一两天吧 我不知道，好像这个，是我表达自我的出口，是我的捧哏，是我的于谦。 这部分是我尽量绞尽脑汁想出来的例子，因为我知道，新手村很容易放弃。但是我是一个奇怪的人，我的例子不适用。但我依然希望，不要强迫自己，不要努力，去寻找自己的内在驱动，去优化整个流程，去获取奖励，去迎接奇迹。没有什么未来，是值得粗暴的强迫自己做什么来换来的。\n","date":"30 August 2023","permalink":"/leetcode-tour/start/","section":"LeetCode Tour","summary":"玩游戏时会上瘾的。如果玩过游戏的话。\nleetcode也是游戏，而且不过是一个普通高中智商的游戏，但是必须通过新手村。\n假如一个rpg游戏，新手村会告诉你，游戏的大致规则，装备的等级玩法，什么时候去刷什么怪物，用什么技能，出什么装备等\nleetcode新手村，同样会告诉，知识点的等级，什么时候去做什么样的题目，用什么模版等。只要过了新手村，就知道怎么玩leetcode。\n但是新手村很难过，除非上瘾\n触发 # 你知道吗？微信有一个功能，你喜欢的女孩的提示音，和其他人的不同\n微信当然没有这个功能，是你给微信添加了这个功能，当提示音响起的时候，你会迫不及待的去打开手机，打开微信。你心甘情愿的被这个声音控制，然后执行后续一些列动作\n你真的会骗自己吗？\n对工作不稳定的恐惧。 对海岛，旅居，新鲜事的向往 对年收入100w的生活的好奇 之前带一个人一起刷题，所以责任感让我必须每天投入 流程 # 心流\n我最爱的一个例子\n21. Merge Two Sorted Lists\n这是一道简单题，需要合并两个增序链表，当做完这道题后，会掌握一个merge(l1,l2)的写法，当然现在不需要知道。\n23. Merge k Sorted Lists\n这是一道困难题，合并[l1,l2,l3,l4] ,应该如何做呢。下面是伪代码","title":"导读"},{"content":"","date":"30 August 2023","permalink":"/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法"},{"content":"","date":"30 August 2023","permalink":"/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E8%83%BD/","section":"Tags","summary":"","title":"编程技能"},{"content":"","date":"29 August 2023","permalink":"/tags/ai/","section":"Tags","summary":"","title":"AI"},{"content":"","date":"29 August 2023","permalink":"/tags/github-hot/","section":"Tags","summary":"","title":"github hot"},{"content":" 核心 # 数据和AI模型更加友好调用 vs empowers developers to connect any AI/ML model to any datasource. 场景和AI模型列表 案例分析 # 使用场景 Prompt chatbot Your are a twitter bot, your name is Snoop Stein (@snoop_stein), and you are helping people with their questions, you are smart and hilarious at the same time. From input message: {{text}} 图片聚合 \u0026lsquo;{{text}}, 8K 问答 answer the question of text:{{question}} about text:{{article_title}} 语义分析 describe the sentiment of the reviews strictly as \u0026ldquo;positive\u0026rdquo;, \u0026ldquo;neutral\u0026rdquo;, or \u0026ldquo;negative\u0026rdquo;. \u0026ldquo;I love the product\u0026rdquo;:positive \u0026ldquo;It is a scam\u0026rdquo;:negative \u0026ldquo;{{review}}. Hugging Face\n算法类型 具体算法 中文解释和说明 Text Classification Spam 垃圾邮件识别 Sentiment 情感分析 Sentiment (Finance) 财经情感分析 Emotions (6) 六种情绪分类 Toxicity 毒性文本识别 ESG (6) 环境社会治理分类 ESG (26) 环境社会治理分类 Hate Speech 仇恨言论识别 Crypto Buy Signals 加密货币买入信号识别 US Political Party 美国政党分类 Question Detection 问题识别 Industry 行业分类 Zero-Shot Classification Bart 零样本分类 Translation English to French (T5) 英文到法文翻译 Summarization Bart 文本摘要 Google Pegasus Google Pegasus 模型 如何实现 # 类名称 类描述 Base 基础类，所有数据库映射类的基类 NumpyEncoder 用于将 NumPy 类型编码为 JSON 格式的特殊编码器 Array 自定义的 Float 类型，将逗号替换为点号 Json 自定义的 Float 类型，将逗号替换为点号 Semaphor 信号量类，用于标识实体的状态 PREDICTOR_STATUS 枚举类，定义预测器的不同状态 Predictor 预测器类，存储预测器的相关信息和配置 Project 项目类，存储项目的相关信息 Log 日志类，存储系统日志信息 Integration 集成类，存储数据集成的信息 File 文件类，存储文件相关信息 View 视图类，存储视图的查询语句 JsonStorage JSON 存储类，用于存储 JSON 数据 Jobs 任务类，存储作业的信息和调度 JobsHistory 任务历史记录类，存储作业执行的历史信息 ChatBots 聊天机器人类，存储聊天机器人相关信息 ChatBotsHistory 聊天机器人历史记录类，存储聊天机器人交互的历史信息 Triggers 触发器类，存储触发器的信息和配置 Tasks 任务类，存储任务的信息和状态 其中比较重要的部分是，Project，Predictor，Jobs，Tasks，ChatBots， integration class Project(Base): __tablename__ = \u0026#39;project\u0026#39; id = Column(Integer, primary_key=True) created_at = Column(DateTime, default=datetime.datetime.now) updated_at = Column(DateTime, default=datetime.datetime.now, onupdate=datetime.datetime.now) deleted_at = Column(DateTime) name = Column(String, nullable=False) company_id = Column(Integer) __table_args__ = ( UniqueConstraint(\u0026#39;name\u0026#39;, \u0026#39;company_id\u0026#39;, name=\u0026#39;unique_project_name_company_id\u0026#39;), ) class Predictor(Base): __tablename__ = \u0026#39;predictor\u0026#39; id = Column(Integer, primary_key=True) updated_at = Column(DateTime, default=datetime.datetime.now, onupdate=datetime.datetime.now) created_at = Column(DateTime, default=datetime.datetime.now) deleted_at = Column(DateTime) name = Column(String) data = Column(Json) # A JSON -- should be everything returned by `get_model_data`, I think to_predict = Column(Array) company_id = Column(Integer) mindsdb_version = Column(String) native_version = Column(String) integration_id = Column(ForeignKey(\u0026#39;integration.id\u0026#39;, name=\u0026#39;fk_integration_id\u0026#39;)) data_integration_ref = Column(Json) fetch_data_query = Column(String) is_custom = Column(Boolean) learn_args = Column(Json) update_status = Column(String, default=\u0026#39;up_to_date\u0026#39;) status = Column(String) active = Column(Boolean, default=True) training_data_columns_count = Column(Integer) training_data_rows_count = Column(Integer) training_start_at = Column(DateTime) training_stop_at = Column(DateTime) label = Column(String, nullable=True) version = Column(Integer, default=1) code = Column(String, nullable=True) lightwood_version = Column(String, nullable=True) dtype_dict = Column(Json, nullable=True) project_id = Column(Integer, ForeignKey(\u0026#39;project.id\u0026#39;, name=\u0026#39;fk_project_id\u0026#39;), nullable=False) training_phase_current = Column(Integer) training_phase_total = Column(Integer) training_phase_name = Column(String) @staticmethod def get_name_and_version(full_name): name_no_version = full_name version = None parts = full_name.split(\u0026#39;.\u0026#39;) if len(parts) \u0026gt; 1 and parts[-1].isdigit(): version = int(parts[-1]) name_no_version = \u0026#39;.\u0026#39;.join(parts[:-1]) return name_no_version, version class Integration(Base): __tablename__ = \u0026#39;integration\u0026#39; id = Column(Integer, primary_key=True) updated_at = Column(DateTime, default=datetime.datetime.now, onupdate=datetime.datetime.now) created_at = Column(DateTime, default=datetime.datetime.now) name = Column(String, nullable=False) engine = Column(String, nullable=False) data = Column(Json) company_id = Column(Integer) __table_args__ = ( UniqueConstraint(\u0026#39;name\u0026#39;, \u0026#39;company_id\u0026#39;, name=\u0026#39;unique_integration_name_company_id\u0026#39;), ) class Jobs(Base): __tablename__ = \u0026#39;jobs\u0026#39; id = Column(Integer, primary_key=True) company_id = Column(Integer) user_class = Column(Integer, nullable=True) name = Column(String, nullable=False) project_id = Column(Integer, nullable=False) query_str = Column(String, nullable=False) start_at = Column(DateTime, default=datetime.datetime.now) end_at = Column(DateTime) next_run_at = Column(DateTime) schedule_str = Column(String) deleted_at = Column(DateTime) updated_at = Column(DateTime, default=datetime.datetime.now, onupdate=datetime.datetime.now) created_at = Column(DateTime, default=datetime.datetime.now) class Tasks(Base): __tablename__ = \u0026#39;tasks\u0026#39; id = Column(Integer, primary_key=True) company_id = Column(Integer) user_class = Column(Integer, nullable=True) # trigger, chatbot object_type = Column(String, nullable=False) object_id = Column(Integer, nullable=False) last_error = Column(String) active = Column(Boolean, default=True) reload = Column(Boolean, default=False) # for running in concurrent processes run_by = Column(String) alive_time = Column(DateTime(timezone=True)) updated_at = Column(DateTime, default=datetime.datetime.now, onupdate=datetime.datetime.now) created_at = Column(DateTime, default=datetime.datetime.now) class (Base): __tablename__ = \u0026#39;chat_bots\u0026#39; id = Column(Integer, primary_key=True) name = Column(String, nullable=False) project_id = Column(Integer, nullable=False) model_name = Column(String, nullable=False) database_id = Column(Integer) params = Column(JSON) updated_at = Column(DateTime, default=datetime.datetime.now, onupdate=datetime.datetime.now) created_at = Column(DateTime, default=datetime.datetime.now) def as_dict(self) -\u0026gt; Dict: return { \u0026#39;id\u0026#39;: self.id, \u0026#39;name\u0026#39;: self.name, \u0026#39;project_id\u0026#39;: self.project_id, \u0026#39;model_name\u0026#39;: self.model_name, \u0026#39;params\u0026#39;: self.params, \u0026#39;created_at\u0026#39;: self.created_at, \u0026#39;database_id\u0026#39;: self.database_id, } 没认真看\nPredictor作为入口，一个企业可以创建Predictor， 并且Predictor可以和Integration绑定 Integration和任务绑定，支持基于数据训练ai以及基于prompt提供功能 task和aitask绑定 并发没看，如果看的话关注一下分离点，感觉值得看的 sql和任务之间的转化没看 后续应该添加数据流分析 总结 # 不是很懂ai，所以细节不深究了 基于数据的页面可以抄，或者基于模型的数据流可以抄 ","date":"29 August 2023","permalink":"/business/mindsdb/","section":"project","summary":"核心 # 数据和AI模型更加友好调用 vs empowers developers to connect any AI/ML model to any datasource. 场景和AI模型列表 案例分析 # 使用场景 Prompt chatbot Your are a twitter bot, your name is Snoop Stein (@snoop_stein), and you are helping people with their questions, you are smart and hilarious at the same time.","title":"mindsdb"},{"content":"别人赚钱你为什么不能，别人做得好你怎么不行，你这个年龄怎么睡得着觉？\n","date":"29 August 2023","permalink":"/business/","section":"project","summary":"别人赚钱你为什么不能，别人做得好你怎么不行，你这个年龄怎么睡得着觉？","title":"project"},{"content":" 静态Arrays # array用来连续存储数据。在严格类型语言例如java，c++， c#等，arrays初始化必须声明大小。这就意味着，列表大小一旦声明不能改变，如果容量到达，不可以再存储。弱语言类型例如Python和Javascript没有静态Array，我们下一个章节讨论\n让我们学习array对应的操作，他们有效并且有用。最常用的操作是\nReading Deletion Insertion Reading # # initialize myArray myArray = [1,3,5] # access an element, where i is the index of the desired value myArray[i] 只要通过index访问元素，时间复杂度就是常量。这是因为每一个myArray的index被映射到一个RAM的address 。这是一个单一的操作，在语法分析中我们称为O(1).这意味着不管array多大，访问元素的时间是不受影响的，将经常是一个单一的操作。\n遍历列表 # for i in range(len(myArray)): print(myArray[i]) # OR i = 0 while i \u0026lt; myArray.size: print(myArray[i]) i = i + 1 💡 列表最后一个元素是arr[len(arr)-1] python中arr[a:b],最后一个元素是arr[b-1],长度为b-a 列表删除 # 尾删除 # 在严格类型中，所有的元素在初始化时，通过0或者默认的值填充。最后一个元素删除，只需要改写对应index对应的值\n删除第i个元素 # 删除第i个元素，需要将i+1个元素依次向前移动一位\n# Remove value at index i before shifting elements to the left. # Assuming i is a valid index. def removeMiddle(arr, i, length): # Shift starting from i + 1 to end. for index in range(i + 1, length): arr[index - 1] = arr[index] # No need to \u0026#39;remove\u0026#39; arr[i], since we already shifted 最坏的情况下，时间复杂度为O(n)\n插入 # 插入元素尾 # 时间复杂度为O(1)\n插入第i个元素 # 从结尾到第i个元素，依次向后移动\n# Insert n into index i after shifting elements to the right. # Assuming i is a valid index and arr is not full. def insertMiddle(arr, i, n, length): # Shift starting from the end to i. for index in range(length - 1, i - 1, -1): arr[index + 1] = arr[index] # Insert at i arr[i] = n 时间复杂度为O(n)\n动态数组 # 动态数组是更加普遍和有用的因为他的扩展(resize)能力。Javascript和Python这些语言是默认的。\n静态和动态的区别是我们不需要在初始化的时候不得不制定一个大小\n在不同的语言中，动态数组可能声明一个默认的大小。然后通过系统自动扩展\n动态数组机制 # 当我们插入一个动态数组的时候，操作系统发现空的空间然复制当前的元素进去。\n由于数组是动态的，当我们在超过capacity的数组中，插入一个元素的时候，我们通过复制他的值到另一个双倍初始化大小的数组中。\n为什么是两倍capacity？ # 让我们深入研究一下为什么是两杯的capacity。这可以被数学公式证明，但是我们只展示简单的公式。下图展示长度为8的列表。想象我们将从他长度为1开始，动态填充他。首先我们添加5， 然后扩大两倍添加6，在扩大两倍添加7和8，在扩大两倍添加9，10，11，12\n上面的大小变化为1-2-4-8. 最后一次操作经常小于或者等于之前的操作（1+2+4 \u0026lt; 8）。我们总共花费了15个操作创建一个结果为8的数组。所以我们可以看作，为了创建n的数组，我们最多花费2n的操作，也就是时间复杂度为O(n)\nstack # stack是一个数据结构包含一组元素，你仅仅可以删除从头。在现实世界中，stack可以被认为是在自助餐的盘子。当你去拿盘子的时候，你只可以从顶部移除，你吃完的时候，也是同样，盘子只能在顶部操作，stack在软件世界中也是一样。\nStack是一个动态的数据结构，维护一个后进先出的操作。最后一个元素放进去，第一个元素出来。stack支持三种操作-push，pop， peek\nPush # push操作添加一个元素到栈顶，动态的数组将被添加一个元素到结尾。这是一个优先的O(1)的操作，在先前的章节中被讨论过。垂直一个列表可以作为一个stack的可视化。这些伪代码描述了这个概念，正如所见，我们添加了1到4到顶端。顶端的指针更新指向最后一个添加的元素。\nstack，是一个数据结构，一个抽象的接口和无所谓你如何实现他-实现这个特性，你只可以添加和删除元素从相同的端。\n由于stack将移除元素和插入元素相反，他可以被用来反转序列。\nPop # pop操作移除顶端最后一个元素，动态的数组返回最后一个元素。这也是一个O(1)的操作在先前讨论的章节中。讨论前面的例子，我们将要pop出4和5。\n在大部分的语言中，在popping前，那是好的措施去检查是否stack是空的，避免错误\nPeek # Peek是最简单的，仅仅需要返回最上面的元素，不需要移除。\n队列 # 队列和堆栈相似，除了队列遵守先进先出。一个真实世界的例子是银行排队。第一个去排队的人第一个受到服务。一个软件世界的例子是打印。例如，如果多个人尽量去打印文档，第一个来的人将先被处理。\n最普通的队列实现是使用一个链表\n队列支持两个操作 enqueue 和 dequeue\nEnqueue # 添加元素到队列尾， 知道队列满了。由于添加对尾不需要移动元素，所以时间复杂度是O(1)\ndef enqueue(self, val): newNode = ListNode(val) # Queue is non-empty if self.right: self.right.next = newNode self.right = self.right.next # Queue is empty else: self.left = self.right = newNode Dequeue # 出队操作从队列前面移除元素。\ndef dequeue(self): # Queue is empty if not self.left: return None # Remove left node and return value val = self.left.val self.left = self.left.next if not self.left: self.right = None return val Kadane\u0026rsquo;s Algorithm 滑动窗口 # 求列表中最大子列表 curValue: 当前窗口值 maxValue: 最大值 change left: curValue \u0026lt; 0; left = left + 1 change right: 遍历 题目 # Maximum Subarray Maximum Sum Circular Subarray max subarray + min subarray = total Longest Turbulent Subarray ","date":"29 August 2023","permalink":"/leetcode-tour/list/","section":"LeetCode Tour","summary":"静态Arrays # array用来连续存储数据。在严格类型语言例如java，c++， c#等，arrays初始化必须声明大小。这就意味着，列表大小一旦声明不能改变，如果容量到达，不可以再存储。弱语言类型例如Python和Javascript没有静态Array，我们下一个章节讨论\n让我们学习array对应的操作，他们有效并且有用。最常用的操作是\nReading Deletion Insertion Reading # # initialize myArray myArray = [1,3,5] # access an element, where i is the index of the desired value myArray[i] 只要通过index访问元素，时间复杂度就是常量。这是因为每一个myArray的index被映射到一个RAM的address 。这是一个单一的操作，在语法分析中我们称为O(1).","title":"列表"},{"content":"","date":"29 August 2023","permalink":"/tags/%E8%9E%8D%E8%B5%84/","section":"Tags","summary":"","title":"融资"},{"content":" 单向链表 # 链表是另一个数据结构，像列表一样顺序存储元素在，但是也有不同。\n第一个不同是，链表通过ListNode对象组成，这个对象包含两个属性：\nvalue - 存储节点值，value可以是任何，character，int 等 next - 存储链表中下一个节点。这个图是ListNode对象的可视化。 创建链表 # 初始化 # 链表是串联ListNode对象在一起。下面是创建你自己的ListNode类的伪代码\nclass ListNode: constructor (value, next): 1. Set value to the desired value, i.e. integer, char, etc. 2. Set the next pointer to the desired node, null by default 看这个例子，这些ListNode对象被串联去构建一个想要的链表。我们通过三个ListNode对象构建，我们初始化他们，通过可以看见的值。 在这个例子中，我们的值是string类型-red，blue，green\n连接 # 下一步，我们需要讲我们的next指针指向ListNode，或者null\nListNode1.next = ListNode2; 遍历 # 去遍历一个链表从头到尾，我们仅仅使用一个简单的while循环\nlet cur = ListNode1; while (cur) { cur = cur.next; } 开始执行这段代码，我们开始遍历从头，ListNode1， 绑定它与cur变量，当作我们目前所在的节点。我们保持运行while循环和升级我们cur节点到next节点直到发现节点是null-意味着我们到链表最后和遍历结束。遍历是O(n)\n循环链表 # 一个有趣的情景是listNode3下一个节点指向ListNode1，而不是null。这将要创建一个无限的循环和程序将要崩溃。这是因为我们从来不会达到链表的结尾。在ListNode3之后，ListNode3.next将指向ListNode1，然后到ListNode2， 再到ListNode3， 返回ListNode1，创建一个从来不会停止的循环 单向链表的操作 # 链表有一个head指针和一个尾指针。头指针指向链表第一个元素，ListNode1， 尾指针指向最后一个元素，ListNode3.如果只有一个元素，头尾指针指向相同的节点。\n添加(尾插) # 链表的一个优势是添加一个元素的时间复杂度是O(1)。添加节点是不需要移动的，因为我们已经指向了头和尾。我们上面的例子，如果我们想添加ListNode4到链表结尾，我们将添加到tail后。一旦ListNode4被添加，我们更新我们的tail指针到ListNode4.这个操作将被完成在O(1)的时间复杂度因为只有一个操作。这个操作类似如下\ntail.next = ListNode4; tail = ListNode4; 删除(头删) # 删除链表头节点花费O(1)。如果没有节点指针，需要花费n步骤遍历获取。删除一个特殊的节点，我们叫做y， 也就是跳过y，更新y前指针next节点到y后面的节点。这被称为next指针从新连接\n可视化会更清楚。说回上面的例子，我们想删除ListNode2.我们的头指针是ListNode1, head.next指针是ListNode2.由于ListNode2不存在，我们需要更新我们head.next指针到ListNode3. 通过从新连接next指针就像head.next.next，可以访问ListNode3. head.next = head.next.next 双向链表 # 你已经学习过了单向链表，让我们继续学习他的变种，双向链表。就像名字的含义一样，他被叫双向链表是因为每个节点有两只指针。我们有一个prev 指向前面的节点，额外有一个next指针。如果prev指针指向null，表明节点是链表头\n双向链表操作 # 插入 # 和单向链表一样，插入一个节点到双向链表需要O(1)的时间复杂度。只是在操作上，我们也需要更新prev指针\n例如，查看下面的例子，有三个节点在双向指针中，ListNode1， ListNode2, ListNode3. 现在我们有另一个节点，ListNode4 ，我们将要插入他。我们知道我们需要更新ListNode3的next指针和ListNode4的prev指针。这个伪代码描述了这个过程。\ntail.next = ListNode4 ListNode4.prev = tail tail = tail.next 删除 # 回到这个列表，删除也是O(1)的操作。这里不需要移动和遍历\nListNode2 = tail.prev; ListNode2.next = null; tail = ListNode2; 访问 # 时间复杂度为O(n)\n","date":"27 August 2023","permalink":"/leetcode-tour/link/","section":"LeetCode Tour","summary":"单向链表 # 链表是另一个数据结构，像列表一样顺序存储元素在，但是也有不同。\n第一个不同是，链表通过ListNode对象组成，这个对象包含两个属性：\nvalue - 存储节点值，value可以是任何，character，int 等 next - 存储链表中下一个节点。这个图是ListNode对象的可视化。 创建链表 # 初始化 # 链表是串联ListNode对象在一起。下面是创建你自己的ListNode类的伪代码\nclass ListNode: constructor (value, next): 1. Set value to the desired value, i.e. integer, char, etc.","title":"链表"},{"content":" 队列 # 队列和堆栈相似，除了队列遵守先进先出。一个真实世界的例子是银行排队。第一个去排队的人第一个受到服务。一个软件世界的例子是打印。例如，如果多个人尽量去打印文档，第一个来的人将先被处理。\n实现和操作 # 最普通的队列实现是使用一个链表\n队列支持两个操作 enqueue 和 dequeue\n入队 # 添加元素到队列尾， 直到队列满了。由于添加对尾不需要移动元素，所以时间复杂度是O(1)\ndef enqueue(self, val): newNode = ListNode(val) # Queue is non-empty if self.right: self.right.next = newNode self.right = self.right.next # Queue is empty else: self.left = self.right = newNode 出队 # 出队操作从队列前面移除元素。\ndef dequeue(self): # Queue is empty if not self.left: return None # Remove left node and return value val = self.left.val self.left = self.left.next if not self.left: self.right = None return val 优先级队列 # 我们已经学习了，先进先出的队列，但是优先级队列是，基于优先级移除元素。优先级越高，越先被删除。\n堆 # 优先级队列由一个堆实现，是一个特定的，基于树的数据结构，是一个复杂的二叉树。\n最小堆: 根节点是最小的值 最大堆: 根节点有最大的值 在这个章节，我们将要聚焦在最小堆，但是这个实现和最大堆相似 堆结构属性 # 一个二叉树堆是一个完全二叉树，每一层都被完全填满，除了最底下的一层，被填充顺序的从左右到右边。\n堆数据属性 # 对于一个最小堆的顺序属性是，子孙的值应该比他们的祖先更大。换句话说，如果我们有一个树，他的根节点是y ，左右两边的子树的每一个节点应该大于等于y ，这是一个递归的属性。\n下图展示一个堆 实现 # 二叉堆使用array作为属性。让我们实现一个如下的二叉堆 我们用一个长度为n+1的列表实现二叉堆，其中，n是元素个数。我们将要访问我们的节点在相同的顺序，就像我们广度优先访问树，一层层，从左到右。我们将要顺序插入列表。然而我们开始填充他们从1，而不是0\n我们从1开始填充是因为，它帮助我们找到节点左子树，右子树和根节点的位置。可以通过下面的公式 \\(leftChild = 2*i\\) \\(rightChild = 2*i+1\\) \\(parent =i/2\\) 例如，列表下标为2，节点值为19\nparent: 2 / 2 = 1 leftChild: 2 * 2 = 4 rightChild: 2 * 2 + 1 = 5 基于以上我们可以初始化堆\nclass Heap: heap = a list of integers, objets etc. constrtuctor(): heap = intialize the list heap.add(0) 操作 # push # 用之前的堆：[14,19,16,21,26,19,68,65,30,null,null,null,null,null,null] ，添加17 。并且添加17之后，我们维护结构和顺序的属性。 因为一个堆是一个完全二叉树，我们需要填充节点通过连续的方式，添加17 应该发生在索引10的位置。 因为17大于他的父亲，26 ， 它需要被交换直到不再大于他的父亲。所以，我们交换17和26和17的父亲是19 ，再一次不匹配最小堆。我们再一次交换，现在17的父节点是14 ，这时候满足条件\ndef push(self, val): self.heap.append(val0 i = len(self.heap) - 1 while i \u0026gt; 1 and self.heap[i] \u0026lt; self.heap[i//2]: tmp = self.heap[i] self.heap[i] = self.heap[i//2] self.heap[i//2] = tmp i = i // 2 Pop # 利用上图，将最后一层的最后一个节点和根节点交换，这时候我们满足了堆的结构属性，不满足堆的数据属性。需要找到30应该在的节点位置。我们循环交换30与子节点min(left_child, right_child)\ndef pop(self): if len(self.heap) == 1: return None if len(self.heap) == 2: return self.heap.pop() res = self.heap[1] # move last value to root self.heap[1] = self.heap.pop() i = 1 # order while 2 * i \u0026lt; len(self.heap): if (2 * i + 1 \u0026lt; len(self.heap) and self.heap[2 * i + 1] \u0026lt; self.heap[2 * i] and self.heap[i] \u0026gt; self.heap[2 * i + 1]): # Swap right child tmp = self.heap[i] self.heap[i] = self.heap[2 * i + 1] self.heap[2 * i + 1] = tmp i = 2 * i + 1 elif self.heap[i] \u0026gt; self.heap[2 * i]: # Swap left child tmp = self.heap[i] self.heap[i] = self.heap[2 * i] self.heap[2 * i] = tmp i = 2 * i else: break return res 时间复杂度 # Get O(1) Push O(log n) Pop O(log n) ","date":"26 August 2023","permalink":"/leetcode-tour/queue/","section":"LeetCode Tour","summary":"队列 # 队列和堆栈相似，除了队列遵守先进先出。一个真实世界的例子是银行排队。第一个去排队的人第一个受到服务。一个软件世界的例子是打印。例如，如果多个人尽量去打印文档，第一个来的人将先被处理。\n实现和操作 # 最普通的队列实现是使用一个链表\n队列支持两个操作 enqueue 和 dequeue\n入队 # 添加元素到队列尾， 直到队列满了。由于添加对尾不需要移动元素，所以时间复杂度是O(1)\ndef enqueue(self, val): newNode = ListNode(val) # Queue is non-empty if self.right: self.right.next = newNode self.","title":"优先级队列"},{"content":"我们已经谈论过TreeSet和TreeMaps在先前的章节，让我们讨论，如何使用hashing实现map和set。在这个章节，我们将聚焦在使用HashSet和HashMap.\n当提到唯一，数量，频率就想到hash。面试一般不会专门考察\n时间复杂度 # Operation TreeMap HashMap Array Insert O(log n) O(1) O(n) Remove O(log n) O(1) O(n) Search O(log n) O(1) O(log n) Inorder Traversal O(n) hash map 作用 # hashmap的副作用，存储没有顺序，如果想遍历所有的key需要O(nlogn)时间复杂度\n因为hashmap不允许重复的key和有一个key-value值，我们可以使用他们去统计key的频率。返回我们电话本的例子，我们可以统计电话出现次数。\n下面的列表的例子中，我们可以将所有的元素添加到列表的keys。因为hash map不允许重复，我们可以使用这个变成我们的优势，如果名字出现，我们只需要增加1.如果没有出现，我们添加到我们的列表中\n[\u0026quot;alice\u0026quot;, \u0026quot;brad\u0026quot;, \u0026quot;collin\u0026quot;, \u0026quot;brad\u0026quot;, \u0026quot;dylan\u0026quot;, \u0026quot;kim\u0026quot;]\nnames = [\u0026#34;alice\u0026#34;, \u0026#34;brad\u0026#34;, \u0026#34;collin\u0026#34;, \u0026#34;brad\u0026#34;, \u0026#34;dylan\u0026#34;, \u0026#34;kim\u0026#34;] countMap = {} for name in names: # If countMap does not contain name if name not in countMap: countMap[name] = 1 else: countMap[name] += 1 ","date":"25 August 2023","permalink":"/leetcode-tour/hash/","section":"LeetCode Tour","summary":"我们已经谈论过TreeSet和TreeMaps在先前的章节，让我们讨论，如何使用hashing实现map和set。在这个章节，我们将聚焦在使用HashSet和HashMap.\n当提到唯一，数量，频率就想到hash。面试一般不会专门考察\n时间复杂度 # Operation TreeMap HashMap Array Insert O(log n) O(1) O(n) Remove O(log n) O(1) O(n) Search O(log n) O(1) O(log n) Inorder Traversal O(n) hash map 作用 # hashmap的副作用，存储没有顺序，如果想遍历所有的key需要O(nlogn)时间复杂度","title":"哈希"},{"content":" One Branch # 递归是一个比较容易绊住脑子的问题，所以如果没有直接理解，也不要泄气\n递归是，函数调用自己，并且产生相同的输出。同时也可以基于迭代函数可以通过while或者for来实现循环。 基础条件 函数调用自身 让我们计算n的阶乘， 这个公式是，n! = n*(n-1)*(n-2)..*1，等价于 n! = n * (n-1)!\nfunction factorial(n) { if (n \u0026lt;= 1) { return 1; } return n * factorial(n - 1); } // example , 线性递归 5! = 5 * 4! 4! = 4 * 3! 3! = 3 * 2! 2! = 2 * 1! 按照基础条件和函数调用自身这两部分分析基础条件\n基础条件：factorial(1) = 1 函数调用自身：n! = n * (n-1)! 当代码到最后一行，输入为5， 我们得到：5factorial(4)，开始继续执行函数从第一行，输入4…以此类推直到最后2factorial(1)，基础条件触发。\n如图所示计算过程 递归与迭代 # 所有递归都可以被改为迭代，递归表达的是抽象能力，迭代表达的是逻辑能力。\nlet n = 5; let res = 1; while (n \u0026gt; 1) { res = res * n; n--; } Two Branch # 更有趣的案例是双分支的递归。让我们依然通过数学的例子来解释，Fibonacci序列。这个公式 f(1)=1;f(0)=1;f(n) = f(n-1) + f(n-2)\nfunction fibonacci(n) { // Base case: n = 0 or 1 if (n \u0026lt;= 1) { return n; } // Recursive case: fib(n) = fib(n - 1) + fib(n - 2) return fibonacci(n - 1) + fibonacci(n - 2); } 基础条件\n体现在叶子节点 f(0) 和 f(1) 函数调用自己\n图中节点自己调用自己 tips: 在构建时，可以简化流程，只画出函数调用图 复杂度分析 # 让我们观察这个树，第一层是1，第二层是2，第三层是4，每一层是2*上一层。\n这里用到了等比数列求和公式， 每层相加是2ⁿ⁺¹-2, 也就是 O(2的n次方)\n","date":"24 August 2023","permalink":"/leetcode-tour/recursion/","section":"LeetCode Tour","summary":"One Branch # 递归是一个比较容易绊住脑子的问题，所以如果没有直接理解，也不要泄气\n递归是，函数调用自己，并且产生相同的输出。同时也可以基于迭代函数可以通过while或者for来实现循环。 基础条件 函数调用自身 让我们计算n的阶乘， 这个公式是，n! = n*(n-1)*(n-2)..*1，等价于 n! = n * (n-1)!\nfunction factorial(n) { if (n \u0026lt;= 1) { return 1; } return n * factorial(n - 1); } // example , 线性递归 5!","title":"递归"},{"content":" 插入排序 # 插入排序是一个排序算法。是最简单的排序算法，很适合数据量很小的时候使用\n概念 # 将元素插入到已经排序好的列表中 [2,3,4,1,6]这个列表。我们将2看做已经排序的列表，将3拿出来，插入到2后面。之后将2，3看做已经排序的列表，将4拿出来插入到2, 3中，直到结束\nj代表已经排序的列表最后一个值的指针。j+1就是下一个待排数据 待排数据与已排列表的进行冒泡排序，比如1要排入[2,3,4], 1和4交换，变成[2,3,1,4],1在和3交换变成[2,1,3,4] function insertionSort(arr) { for (let i = 1; i \u0026lt; arr.length; i++) { let j = i - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j+1] \u0026lt; arr[j]) { let tmp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = tmp; j--; } } return arr; } 时间复杂度 # o(n)\n合并排序 # 合并排序的概念是非常简单的。分割列表到一半，排序他们，合并已经排序的列表，变成最终的排序列表, 重复这个步骤直到子列表长度为1。\n整个过程类似双分支递归。\n让我们谈论一个长度为5的列表最为例子，[3,2,4,1,6] 。我们的工作是对他进行增量排序。 function mergeSort(arr, l, r) { if (l \u0026lt; r) { // Find the middle point of arr let m = Math.floor((l + r) / 2); mergeSort(arr, l, m); // sort left half mergeSort(arr, m+1, r); // sort right half merge(arr, l, m, r); // merge sorted halfs } return arr; } merge函数如下\n// Merges two subarrays of arr[]. // First subarray is arr[l..m] // Second subarray is arr[m+1..r] function merge(arr, l, m, r) { // Find lengths of two subarrays to be merged let length1 = m - l + 1; let length2 = r - m; // Create temp arrays let L = new Array(length1); let R = new Array(length2); // Copy the sorted left \u0026amp; right halfs to temp arrays for (let i = 0; i \u0026lt; length1; i++) { L[i] = arr[l + i]; } for (let j = 0; j \u0026lt; length2; j++) { R[j] = arr[m + 1 + j]; } // initial indexes of left and right sub-arrays let i = 0; // index for left let j = 0; // index for right let k = l; // Initial index of merged subarray array // Merge the two sorted halfs leto the original array while (i \u0026lt; length1 \u0026amp;\u0026amp; j \u0026lt; length2) { if (L[i] \u0026lt;= R[j]) { arr[k] = L[i]; i++; } else { arr[k] = R[j]; j++; } k++; } // One of the halfs will have elements remaining while (i \u0026lt; length1) { arr[k] = L[i]; i++; k++; } while (j \u0026lt; length2) { arr[k] = R[j]; j++; k++; } } 时间复杂度 # o(nlogn) 快速排序 # 快速排序的方法是选择一个索引，被称为pivot ，每一轮，分割这个列表例如在它左边都小于或者等于它，右边都大于它，然后依次排序左右两个子列表 function quickSort(arr, s, e) { if (e - s + 1 \u0026lt;= 1) { return arr; } let pivot = arr[e]; let left = s; // pointer for left side // Partition: elements smaller than pivot on left side for (let i = s; i \u0026lt; e; i++) { if (arr[i] \u0026lt; pivot) { let tmp = arr[left]; arr[left] = arr[i]; arr[i] = tmp; left++; } } // Move pivot in-between left \u0026amp; right sides arr[e] = arr[left]; arr[left] = pivot; // Quick sort left side quickSort(arr, s, left - 1); // Quick sort right side quickSort(arr, left + 1, e); return arr; } 桶排序 # 先把元素放入桶中，在基于桶的顺序将元素拿出进行排序\nfunction bucketSort(arr) { // Assuming arr only contains 0, 1 or 2 const counts = [0, 0, 0]; // Count the quantity of each val in arr for (let i = 0; i \u0026lt; arr.length; i++) { counts[arr[i]] += 1; } // Fill each bucket in the original array let i = 0; for (let n = 0; n \u0026lt; counts.length; n++) { for (let j = 0; j \u0026lt; counts[n]; j++) { arr[i] = n; i++; } } return arr; } ","date":"23 August 2023","permalink":"/leetcode-tour/sort/","section":"LeetCode Tour","summary":"插入排序 # 插入排序是一个排序算法。是最简单的排序算法，很适合数据量很小的时候使用\n概念 # 将元素插入到已经排序好的列表中 [2,3,4,1,6]这个列表。我们将2看做已经排序的列表，将3拿出来，插入到2后面。之后将2，3看做已经排序的列表，将4拿出来插入到2, 3中，直到结束\nj代表已经排序的列表最后一个值的指针。j+1就是下一个待排数据 待排数据与已排列表的进行冒泡排序，比如1要排入[2,3,4], 1和4交换，变成[2,3,1,4],1在和3交换变成[2,1,3,4] function insertionSort(arr) { for (let i = 1; i \u0026lt; arr.length; i++) { let j = i - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j+1] \u0026lt; arr[j]) { let tmp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = tmp; j--; } } return arr; } 时间复杂度 # o(n)","title":"排序"},{"content":" 二差查找 # 二差查找是一个有效的方式，在一个排序列表中查询元素。\n他的核心是，二差查找在中间分隔列表，这个点叫mid，并且比较目标值和mid值。如果mid的值比目标值更小，淘汰掉左半部分和查找mid的右半部分。如果mid 比目标目标值更大，我们查找左部分。我们要么发现目标值，或者决定目标值不存在。\n在面试和算法问题中，通常有两种类型的二叉搜索问题：\nSearch Array-一个排序列表，目标被给定和目标是确定目标是否在列表中 Search Range-一个范围被给，没有特别指定目标 二叉搜索的机制 # 目标值被给作为输入，但是我们需要计算mid 。mid被初始化通过最左边和最右边的索引值相加除2。这允许我们有两个相等的列表，在二叉查找中，我们需要有以下部分\nL - 目前子列表最左边 R -目前列表最右边 mid - L+R/2 通过这个节点分隔列表成两部分 我们目前搜索target的结果知道要么我们找到target，或者L指针大于R指针，代表target不存在\nTarget 存在在array, 返回 # 让我们讨论上面的概念和举例子。拿这个array arr=[1,2,3,4,5,6,7,8], 5是我们的目标\n我们知道L从0开始和R从7开始，在arr.length-1 .计算mid （7+0）/2 =3.现在我们可以比较索引为3的值和我们的目标值\n4比5小，说明我们需要查询更大的数字，由于列表是有序的，最大的值在右边。于是我们需要移动L到mid+1，限定我们最低的界限。R指针不变\n在下一个迭代中，计算mid等于5.查看第5个元素是6，比5大，于是R移动到mid-1 ，因为我们需要更小的元素。L指针指向4并且R也指向4.新的mid结果是4，我们目标存在在索引为4的元素，返回mid arr = [1, 3, 3, 4, 5, 6, 7, 8] def binarySearch(arr, target): L, R = 0, len(arr) - 1 while L \u0026lt;= R: mid = (L + R) // 2 if target \u0026gt; arr[mid]: L = mid + 1 elif target \u0026lt; arr[mid]: R = mid - 1 else: return mid return -1 目标不存在列表中 # 时间复杂度 # 这个工作非常简单，我们可以切分列表，直到列表尺寸是1.时间复杂度是log（n），\n","date":"22 August 2023","permalink":"/leetcode-tour/search/","section":"LeetCode Tour","summary":"二差查找 # 二差查找是一个有效的方式，在一个排序列表中查询元素。\n他的核心是，二差查找在中间分隔列表，这个点叫mid，并且比较目标值和mid值。如果mid的值比目标值更小，淘汰掉左半部分和查找mid的右半部分。如果mid 比目标目标值更大，我们查找左部分。我们要么发现目标值，或者决定目标值不存在。\n在面试和算法问题中，通常有两种类型的二叉搜索问题：\nSearch Array-一个排序列表，目标被给定和目标是确定目标是否在列表中 Search Range-一个范围被给，没有特别指定目标 二叉搜索的机制 # 目标值被给作为输入，但是我们需要计算mid 。mid被初始化通过最左边和最右边的索引值相加除2。这允许我们有两个相等的列表，在二叉查找中，我们需要有以下部分\nL - 目前子列表最左边 R -目前列表最右边 mid - L+R/2 通过这个节点分隔列表成两部分 我们目前搜索target的结果知道要么我们找到target，或者L指针大于R指针，代表target不存在\nTarget 存在在array, 返回 # 让我们讨论上面的概念和举例子。拿这个array arr=[1,2,3,4,5,6,7,8], 5是我们的目标","title":"查找"},{"content":" 属性 # 根节点 # 跟节点是树中最高的节点，没有父节点。在树中所有的节点可以到达根节点。\n叶子节点 # 叶子节点是没有孩子的节点。最后一层担保出现叶子节点，但是他也可以出现在其他层 孩子 # 孩子节点是这个节点的左节点和右节点\n高度 # 二叉树的高度是说从根节点到叶子节点。单一节点高度为1\n另外，就像列表从0开始，这里的高度也可能从0开始\n深度 # 深度是指，这个节点到根节点 all zhe way up。应该是经历的节点个数\n祖先 # 链接到这个节点下面的所有的节点，认为这个节点是祖先\n子孙 # 子孙是一个节点的孩子或者是孩子的孩子\n二叉树 # 二叉树是另一个数据结构，卷入了节点和指针。我们谈论了指针在链表的章节。我们通过next和prev指针链接节点。在二叉树中的节点也有两个指针，但是我们叫他们左指针和右指针。二叉树的第一个节点被称为跟节点。我们通过一条线代表节点。\n节点的值可以是任何数据类型。一个TreeNode类看起来如下。注意他的实现和ListNode很相似，我们在list章节提过，现在我们是left_child和right_child\nclass TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None 如果一个节点没有任何孩子，他被当作leaf节点。如果一个节点只有一个孩子，left或者right，他被认为是一个non-leaf节点\n二叉树的节点指针不像列表一样只能指向一个方向。环不被二叉树允许。数学角度上讲，一个二叉树是一个无向无循环图。这也意味着，叶子几点保证存在\n下面的部分展示二叉树如何被生成和使用，在面试中，他是重要的\n深度优先搜索 # 深度优先是一种方式遍历二叉搜索树，优先深度而不是广度。\n这个方式是说遍历树，先从左子树或者右子树，知道没有节点留下。这里有几种方式实现深度优先遍历算法。这些方式遍历节点，根，左子树，右子树在不同的顺序。这些方式是\n中序 先序 后序 深度优先搜索最好的实现是递归。当然你可以使用堆栈加迭代来实现，只不过更复杂\n让我们从左到右遍历一下这个树[4,3,6,2,null,5,7]\n中序遍历 # 一个中序遍历顺序是先左子节点，在父节点，在右子节点。中序遍历的结果是一个排序结果。\ndef inorder(root): if not root: return inorder(root.left) print(root.val) inorder(root.right) 节点的这个顺序结果是[2,3,4,5,6,7]，是顺序的。记住顺序特别重要，先左在右。如果我们先右边在左边，我们得到一个逆序列表\n这个遍历顺序可视化展示如图 先序遍历 # 根-左-右\ndef preorder(root): if not root: return print(root.val) preorder(root.left) preorder(root.right) 后序遍历 # def postorder(root): if not root: return postorder(root.left) prstorder(root.right) print(root.val) 广度优先搜索 # 在深度优先中，我们优先深度。对于广度优先，我们优先广度。我们聚焦在遍历当前层的所有节点之后去下一层\ndef bfs(root): queue = deque() if root: queue.append(root) level = 0 while len(queue) print(\u0026#34;level: \u0026#34;, level) for i in range(len(queue)): curr = queue.popleft() print(curr.val) if curr.left: queue.append(curr.left) if curr.right: queue.append(curr.right) level += 1 二叉搜索树 # 二叉搜索树是一种二叉树，有特定的存储规则。这个规则是，每一个左孩子必须小于他的父亲和每一个右孩子，必须大于他的父亲。BST不允许重复。\nBST Search # 这里是递归最好的场景。你可以探索递归，然而，因为需要维持一个栈，更加复杂。对于递归， 就像之前讨论的， 我们需要一个调用函数本身的基本应用\n让我们谈论这个树[2,1,3,null,null,null,4] 作为例子，和搜索target 3.\n在二叉搜索中，如果目前的元素比目标元素更大， 我们去左边和如果当前元素比目标元素更小，我们去右边。一个和列表查找相似的流程。我们树左边的所有节点小于当前节点，右边所有节点大于当前节点。\n如果目标在树中存在我们返回true，否则，我们返回false\n在这个例子中，我们先开始比较根节点和target ，2小，所以我们目标节点必须在右边，意味着我们可以抛弃左子树。当我们到达右边，第一个节点是3，等于目标节点，所以我们可以返回true，意味着目标节点存在。\n下面展示了上面的流程 def search(root, target): if not root: return False if target \u0026gt; root.val: return search(root.right, target) elif target \u0026lt; root.val: return search(root.left, target) else: return True 插入和删除 # 如果我们想插入一个新的节点到BST（Binary Search Tree），我们首先不得不遍历BST发现正确的位置，然后插入节点。\n如果我们有一个BST[4]，希望插入6，我们可能得到[4,null,6]或者[6,4,null].这些都是有价值的BST.在第一个例子中，我们添加6作为叶子节点，是更简单的流程比第二个例子。 def insert(root, val): if not root: return TreeNode(val) if val \u0026gt; root.val: root.right = insert(root.right, val) elif val \u0026lt; root.val: root.left = insert(root.left, val) return root 移除 # 在从BST移除之前，我们可以构建两种情况\n目标节点有0或者1个孩子 目标节点有两个孩子 目标节点有0或者1个孩子，直接返回不为空的子节点 有两个孩子 如果我们想删除一个节点，有两个孩子，比如说6， 我们替换节点in-order successor。\nin-order successor是右子树最左边的节点。换个角度看，是大于目标节点的最小节点。这将要确信，结果树仍然是一个符合条件的二叉搜索树。 def minValueNode(root): curr = root while curr and curr.left: curr = curr.left return curr def remove(root, val): if not root: return None if val \u0026gt; root.val: root.right = remove(root.right,val) elif val \u0026lt; root.val: root.left = remove(root.left, val) else: if not root.left: return root.right elif not root.right: return root.left else: minNode = minValueNode(root.right) root.val = minNode.val root.right = remove(root.right, minNode.val) return root ","date":"21 August 2023","permalink":"/leetcode-tour/tree/","section":"LeetCode Tour","summary":"属性 # 根节点 # 跟节点是树中最高的节点，没有父节点。在树中所有的节点可以到达根节点。\n叶子节点 # 叶子节点是没有孩子的节点。最后一层担保出现叶子节点，但是他也可以出现在其他层 孩子 # 孩子节点是这个节点的左节点和右节点\n高度 # 二叉树的高度是说从根节点到叶子节点。单一节点高度为1\n另外，就像列表从0开始，这里的高度也可能从0开始\n深度 # 深度是指，这个节点到根节点 all zhe way up。应该是经历的节点个数\n祖先 # 链接到这个节点下面的所有的节点，认为这个节点是祖先\n子孙 # 子孙是一个节点的孩子或者是孩子的孩子\n二叉树 # 二叉树是另一个数据结构，卷入了节点和指针。我们谈论了指针在链表的章节。我们通过next和prev指针链接节点。在二叉树中的节点也有两个指针，但是我们叫他们左指针和右指针。二叉树的第一个节点被称为跟节点。我们通过一条线代表节点。","title":"树"},{"content":"回朔是一个算法，类似于我们之前讨论的二叉树深度优先算法。它通过暴力的方式解决，想象我们需要寻找图片锁的所有解决方式。我们不得不做一个过渡的查询发现所有组合的可能。这不是一个好的算法，拿到所有的组合，并且一个个的遍历所有组合。有一种回朔的方式，我们探索一种可能的方式去解决问题，如果我们没有成功，我们回去和探索其他的方式直到我们解决了问题\n例子 # 我们已经直接讨论过，回朔是什么，和讨论了DFS。让我们看一下如何解决下面的问题\n💡 判断一个路径是否存在，从跟节点到叶子节点， 并且不包含任何0节点 这个问题是在问我们，如果我们从跟节点到叶子节点遍历，如果不包含0，我们返回True， 否则， False\n首先想到的是使用深度优先算法， 我们限制是，我们不能有0的节点。我们也知道，如果树是空的，我们不会存在一个有效的路径。最终，如果我们到达叶子节点，并且没有返回false，我们可以返回true。\n我们假设这个问题，存在这样一条路径，要么在左边，要么在右边。我们先查询左边，如果没有发现，查询右边，如果存在，返回True\n给定这个树，[4,0,1,null,7,2,0] ,路径如图所示。\nclass TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None def canReachLeaf(root): if not root or root.val == 0: return False if not root.left and not root.right: return True if canReachLeaf(root.left): return True if canReachLeaf(root.right): return True return False 让我们看一下这个之前的问题，我们必须返回路径而不是boolean\n在这个问题中，我们可以通过参数path ，path是一个列表存储可用的节点。所以[4,0,1,null,7,3,2,null,null,null,0] ，我们首先插入根节点到列表中。\n由于只有一个有效路径，要么在左子树，要么在右子树。左边更加优先，左子树是无效的因为4的左子树是0 我们返回false和开始迭代检查右子树。到右边，1是有价值的，所以我们添加他到我们的列表中。现在，我们检查3 ，是有价值的，所以添加到我们的列表中。3的左边是空，所以我们返回false。检查3的右子树，不符合要求。所以我们必须移除3 从我们的堆栈中，因为如果存在正确的路径，我们直接返回true 。我们返回3的父节点， 是1， 检查右子树。我们添加2到我们的列表。我们探索2但是2是叶子节点，返回true。我们的有效路径是[4,1,2]\ndef leafPath(root, path): if not root or root.val == 0: return False path.append(root.val) if not root.left and not root.right: return True if leafPath(root.val, path): return True if leafPath(root.val, path) return True # 注意这里开始回朔 path.pop() return False 时间复杂度 # o(n)，因为我们遍历整个树\n其他 # 很多题目中，其实用的是树的树的遍历，加上一些别的操作。回朔也是树的遍历，加别的操作，如果这些操作一旦涉及列表，会变得很抽象，因为列表是可变变量，目前我也没有好的办法\n","date":"20 August 2023","permalink":"/leetcode-tour/backtrack/","section":"LeetCode Tour","summary":"回朔是一个算法，类似于我们之前讨论的二叉树深度优先算法。它通过暴力的方式解决，想象我们需要寻找图片锁的所有解决方式。我们不得不做一个过渡的查询发现所有组合的可能。这不是一个好的算法，拿到所有的组合，并且一个个的遍历所有组合。有一种回朔的方式，我们探索一种可能的方式去解决问题，如果我们没有成功，我们回去和探索其他的方式直到我们解决了问题\n例子 # 我们已经直接讨论过，回朔是什么，和讨论了DFS。让我们看一下如何解决下面的问题\n💡 判断一个路径是否存在，从跟节点到叶子节点， 并且不包含任何0节点 这个问题是在问我们，如果我们从跟节点到叶子节点遍历，如果不包含0，我们返回True， 否则， False\n首先想到的是使用深度优先算法， 我们限制是，我们不能有0的节点。我们也知道，如果树是空的，我们不会存在一个有效的路径。最终，如果我们到达叶子节点，并且没有返回false，我们可以返回true。\n我们假设这个问题，存在这样一条路径，要么在左边，要么在右边。我们先查询左边，如果没有发现，查询右边，如果存在，返回True\n给定这个树，[4,0,1,null,7,2,0] ,路径如图所示。\nclass TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None def canReachLeaf(root): if not root or root.","title":"回朔"},{"content":"我们在这个课程中已经遭遇了图多次。一个图是节点和指针构造的数据结构\n让我们了解一些图的术语首先\n图术语 # 在图中，节点被当作定点和指针链接被当作边。节点位置和边链接也没有限制。\n也有可能，节点没有被任何边链接和这里仍然可以被当作图，一个空的图。\n如果图的边有方向，我们叫做有向图，没有没有方向，我们叫做无向图\n图算法面试 # 图可以被不同数据结构代表。他是一个抽象的概念，一般被下面三种数据结构代表\n矩阵 邻接矩阵 邻接列表 矩阵 # 一个矩阵是一个带有行和列二维数组，图可以被矩阵代表。在下面的代码中，每一个列表，被逗号分隔，代表每一个行。我们有4行或者4列。从0开始，进入第二行可以通过gird[1]和进入第二列可以通过gird[0][1]\n如何用它来表示图形？正如我们提到的，图是抽象的，可以通过多种方式定义。假设网格中的所有 0 都是顶点。为了遍历一个图，我们可以向上、向下、向左、向右移动。如果我们要使用边缘将 0 连接在一起，我们最终会得到一堆连接的零，它们是连接的组件，表示一个图。我们将在下一章讨论矩阵遍历。\n真的用矩阵代表图，就是字面意思 0 代表可以通过，1代表不可以通过 邻接矩阵 # 在是一个不太寻常的表示方式，这里的索引代表定点本身\nadjMatrix = [[0, 0, 0, 0], [1, 1, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]] 因为索引本身代表一个顶点，0代表一个边不存在在给定的索引v1，v2 ，1代表相反。adjMatrix[1][2] == 0 意味着这里没有边在1和2之间。\n邻接列表 # 这是典型的最普通的表示图的方法。这也是两个列表。为了方便，我们可以使用一个类，被叫作GraphNode 和包含一个列表叫做neighbors ，记录所有可以到达的顶点\nclass GraphNode: def __init__(self, val): self.val = val self.neighbors = [] 深度优先算法 # 我们如何接受图的深度优先算法？最好的展示是例子\n我们给下面一个问题\n计算唯一路径从左上角到有下角。一个路径只可以通过0并且相同的cell不可以通过两次\nmatrix = [[0,0,0,0], [1,1,0,0], [0,0,0,1], [0,1,0,0]] 在这个问题中，是关于选择的问题。你可能认为这是相似的和回朔，你是对的。我们之前DFS提到了递归和我们讲使用递归。首先，我们需要去想我们base case。 我们知道，我们可以移动在四个方向，不可以斜着。这就意味着，如果我们超过边界，我们可以返回0.\n我们知道，我们在任何点任何路径中，我们使用暴力DFS，我们将可能没有一个正确的路径，在这种情况，我们回朔。\n在开始，我们树立我们base case。我们尽力去发现唯一路径的数量，我们需要保持计算数量在每一个顶点中。\nbase case # 不存在唯一路径 # 因为我们允许四个方向移动，那是可能的在遍历过程中，我们超过了边界。这就意味着无论是行 c 或者是列 r ， 变成负数，或者超过matrix的长度。那不是问题r和c 超过边界，因为我们需要正确的c和r。我们不可能在matrix[-1][3]中搜索\n如果我们已经到一个**coordinate，**或者目前coordinate是1，说明有价值的路径不存在在这个点中\n所以，因为一个有价值的路径不存在，在所有之前提到的案例中，我们将要返回0，说明不是一个唯一队列。我们很快可以看到我们的代码\n唯一路径存在 # 如果我们没有从先前的例子中返回0，我们已经到达右下角的行，一定是我们找到了一个正确路径。记住，我们定义有价值的路径是存在一个路径从matrix[0][0] to matrix[3][3]。 我们可以返回1和将要增加我们正确路径的计数器。\n实现 # 为了确信我们没有多次访问同一个节点，我们添加一个全局HashSet。\n任何给定的节点，我们可以递归的DFS查询在r+1 ，r-1，c+1， c-1 。如果我们递归返回1，我们count 将要增加和如果返回0，count不变\n在每一个递归调用，我们可以移除所有的导致无效路径的行和列。我们可以确保再次访问，在不同的方向和探索是否有价值的路径存在。\n在下面的代码，我们实现了先前的逻辑。我们添加当前行和列集合。我们的count 初始化是0，因为我们需要保持追踪所有有价值路径。一旦我们递归返回，我们可以移除从set中。因为他可能是有效路径的一部分，从不同的源头。所以，当我们回朔，我们可以在访问一次\ngrid = [[0, 0, 0, 0], [1, 1, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]] # Count paths (backtracking) def dfs(grid, r, c, visit): ROWS, COLS = len(grid), len(grid[0]) if (min(r, c) \u0026lt; 0 or r == ROWS or c == COLS or (r, c) in visit or grid[r][c] == 1): return 0 if r == ROWS - 1 and c == COLS - 1: return 1 visit.add((r, c)) count = 0 count += dfs(grid, r + 1, c, visit) count += dfs(grid, r - 1, c, visit) count += dfs(grid, r, c + 1, visit) count += dfs(grid, r, c - 1, visit) visit.remove((r, c)) return count 可视化\n找到第一个唯一路径\n回朔发现另一个 时间复杂度 # ","date":"19 August 2023","permalink":"/leetcode-tour/graph/","section":"LeetCode Tour","summary":"我们在这个课程中已经遭遇了图多次。一个图是节点和指针构造的数据结构\n让我们了解一些图的术语首先\n图术语 # 在图中，节点被当作定点和指针链接被当作边。节点位置和边链接也没有限制。\n也有可能，节点没有被任何边链接和这里仍然可以被当作图，一个空的图。\n如果图的边有方向，我们叫做有向图，没有没有方向，我们叫做无向图\n图算法面试 # 图可以被不同数据结构代表。他是一个抽象的概念，一般被下面三种数据结构代表\n矩阵 邻接矩阵 邻接列表 矩阵 # 一个矩阵是一个带有行和列二维数组，图可以被矩阵代表。在下面的代码中，每一个列表，被逗号分隔，代表每一个行。我们有4行或者4列。从0开始，进入第二行可以通过gird[1]和进入第二列可以通过gird[0][1]\n如何用它来表示图形？正如我们提到的，图是抽象的，可以通过多种方式定义。假设网格中的所有 0 都是顶点。为了遍历一个图，我们可以向上、向下、向左、向右移动。如果我们要使用边缘将 0 连接在一起，我们最终会得到一堆连接的零，它们是连接的组件，表示一个图。我们将在下一章讨论矩阵遍历。\n真的用矩阵代表图，就是字面意思 0 代表可以通过，1代表不可以通过 邻接矩阵 # 在是一个不太寻常的表示方式，这里的索引代表定点本身\nadjMatrix = [[0, 0, 0, 0], [1, 1, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]] 因为索引本身代表一个顶点，0代表一个边不存在在给定的索引v1，v2 ，1代表相反。adjMatrix[1][2] == 0 意味着这里没有边在1和2之间。","title":"图"},{"content":"让我们现在讨论grid并且找到我们如何通过动态规划处理他。让我们解决下面的问题，和我们图遇到的问题详细\n计算从左上角到右下角唯一路径。你只可以右移和下移动\n让我们带入下面的grid到讨论中，我们只允许右移和下移。边界是，r大于row和c大于col\n暴力法 # 暴力的手段，从0，0，如图所示，箭头代表当前点可以移动的方向。计算给顶点到目的地的唯一节点，我们仅仅将返回值添加到当前坐标上。下图展示蛮力的方法，但是可以看到他的局限性。\n# Brute Force - Time: O(2 ^ (n + m)), Space: O(n + m) def bruteForce(r, c, rows, cols): if r == rows or c == cols: return 0 if r == rows - 1 and c == cols - 1: return 1 return (bruteForce(r + 1, c, rows, cols) + bruteForce(r, c + 1, rows, cols)) 问题 # 这个问题是我们不得不计算一个极点很多次，尤其适用从上到校。\n动态规划手段 # 从上到下 # # Memoization - Time and Space: O(n * m) def memoization(r, c, rows, cols, cache): if r == rows or c == cols: return 0 if cache[r][c] \u0026gt; 0: return cache[r][c] if r == rows - 1 and c == cols - 1: return 1 cache[r][c] = (memoization(r + 1, c, rows, cols, cache) + memoization(r, c + 1, rows, cols, cache)) return cache[r][c] 这里我们添加了一个cache，存储计算过的节点\n从上到下 # 在这种方法中，我们可以从底部开始逐步向上计算。时间复杂度仍然是相同的，只不过这是一种迭代的方法。我们执行这些计算的顺序非常重要。我们必须从右向左计算这些值，这是因为只有当我们达到基本情况时才能得到返回值。\n事实上，我们甚至不需要一个完整的网格来计算任何给定行的值。也就是说，要计算第n行的值，我们只需要n-1行的值。然后，我们可以将前一行更新为当前行。听起来熟悉吗？这与我们在斐波那契数列解法中完全相同的思路！\n# Dynamic Programming - Time: O(n * m), Space: O(m), where m is num of cols def dp(rows, cols): prevRow = [0] * cols for r in range(rows - 1, -1, -1): curRow = [0] * cols curRow[cols - 1] = 1 for c in range(cols - 2, -1, -1): curRow[c] = curRow[c + 1] + prevRow[c] prevRow = curRow return prevRow[0] ","date":"18 August 2023","permalink":"/leetcode-tour/dp/","section":"LeetCode Tour","summary":"让我们现在讨论grid并且找到我们如何通过动态规划处理他。让我们解决下面的问题，和我们图遇到的问题详细\n计算从左上角到右下角唯一路径。你只可以右移和下移动\n让我们带入下面的grid到讨论中，我们只允许右移和下移。边界是，r大于row和c大于col\n暴力法 # 暴力的手段，从0，0，如图所示，箭头代表当前点可以移动的方向。计算给顶点到目的地的唯一节点，我们仅仅将返回值添加到当前坐标上。下图展示蛮力的方法，但是可以看到他的局限性。\n# Brute Force - Time: O(2 ^ (n + m)), Space: O(n + m) def bruteForce(r, c, rows, cols): if r == rows or c == cols: return 0 if r == rows - 1 and c == cols - 1: return 1 return (bruteForce(r + 1, c, rows, cols) + bruteForce(r, c + 1, rows, cols)) 问题 # 这个问题是我们不得不计算一个极点很多次，尤其适用从上到校。","title":"动态规划"},{"content":" 题目 # 视频讲解\n题号 题目 标签 26 Remove Duplicates from Sorted Array 列表 27 Remove Element 列表 682 Baseball Game 列表 20 Valid Parentheses 列表 155 Min Stack 列表 206 Reverse Linked List 递归,链表 21 Merge Two Sorted Lists 链表 707 Design Linked List 链表 1472 Design Browser History 链表 1700 Number of Students Unable to Eat Lunch 链表 509 Fibonacci Number 递归 70 Climbing Stairs 动态规划,递归 23 Merge k Sorted Lists 排序 215 Kth Largest Element in an Array 排序 75 Sort Colors 排序 912 Sort an Array 排序 704 Binary Search 查找 74 Search a 2D Matrix 查找 374 Guess Number Higher or Lower 查找 278 First Bad Version 查找 875 Koko Eating Bananas 查找 700 Search in a Binary Search Tree 树 701 Insert into a Binary Search Tree 树 450 Delete Node in a BST 树 94 Binary Tree Inorder Traversal 树 230 Kth Smallest Element in a BST 树 102 Binary Tree Level Order Traversal 树 199 Binary Tree Right Side View 树 112 Path Sum 回朔 78 Subsets 回朔 39 Combination Sum 回朔 703 Kth Largest Element in a Stream 优先级队列 1046 Last Stone Weight 优先级队列 973 K Closest Points to Origin 优先级队列 217 Contains Duplicate hash 1 Two Sum hash 146 LRU Cache hash 200 Number of Islands 图 695 Max Area of Island 图 1091 Shortest Path in Binary Matrix 图 994 Rotting Oranges 图 133 Clone Graph 图 198 House Robber 动态规划 63 Unique Paths II 动态规划 62 Unique Paths 动态规划 1143 Longest Common Subsequence 动态规划 ","date":"1 August 2023","permalink":"/leetcode-tour/shortcodes/","section":"LeetCode Tour","summary":" 题目 # 视频讲解\n题号 题目 标签 26 Remove Duplicates from Sorted Array 列表 27 Remove Element 列表 682 Baseball Game 列表 20 Valid Parentheses 列表 155 Min Stack 列表 206 Reverse Linked List 递归,链表 21 Merge Two Sorted Lists 链表 707 Design Linked List 链表 1472 Design Browser History 链表 1700 Number of Students Unable to Eat Lunch 链表 509 Fibonacci Number 递归 70 Climbing Stairs 动态规划,递归 23 Merge k Sorted Lists 排序 215 Kth Largest Element in an Array 排序 75 Sort Colors 排序 912 Sort an Array 排序 704 Binary Search 查找 74 Search a 2D Matrix 查找 374 Guess Number Higher or Lower 查找 278 First Bad Version 查找 875 Koko Eating Bananas 查找 700 Search in a Binary Search Tree 树 701 Insert into a Binary Search Tree 树 450 Delete Node in a BST 树 94 Binary Tree Inorder Traversal 树 230 Kth Smallest Element in a BST 树 102 Binary Tree Level Order Traversal 树 199 Binary Tree Right Side View 树 112 Path Sum 回朔 78 Subsets 回朔 39 Combination Sum 回朔 703 Kth Largest Element in a Stream 优先级队列 1046 Last Stone Weight 优先级队列 973 K Closest Points to Origin 优先级队列 217 Contains Duplicate hash 1 Two Sum hash 146 LRU Cache hash 200 Number of Islands 图 695 Max Area of Island 图 1091 Shortest Path in Binary Matrix 图 994 Rotting Oranges 图 133 Clone Graph 图 198 House Robber 动态规划 63 Unique Paths II 动态规划 62 Unique Paths 动态规划 1143 Longest Common Subsequence 动态规划 ","title":"题目"},{"content":"","date":"7 November 2022","permalink":"/examples/blowfish-lite/","section":"Showcase","summary":"","title":"Blowfish Lite"},{"content":" See what\u0026rsquo;s possible with Blowfish. This section contains links to example templates and pages created using Blowfish to get you inspired.\n","date":"7 November 2022","permalink":"/examples/","section":"Showcase","summary":"See what\u0026rsquo;s possible with Blowfish. This section contains links to example templates and pages created using Blowfish to get you inspired.","title":"Showcase"},{"content":"","date":"6 November 2022","permalink":"/examples/blowfish-artist/","section":"Showcase","summary":"","title":"Blowfish Artist"},{"content":"","date":"6 November 2022","permalink":"/examples/blowfish-lowkey/","section":"Showcase","summary":"","title":"Blowfish Lowkey"},{"content":"","date":"7 November 2021","permalink":"/examples/repo-blowfish-lite/","section":"Showcase","summary":"","title":"Blowfish Lite - Repo"},{"content":"","date":"6 November 2021","permalink":"/examples/repo-blowfish-artist/","section":"Showcase","summary":"","title":"Blowfish Artist - Repo"},{"content":"","date":"6 November 2021","permalink":"/examples/repo-blowfish-lowkey/","section":"Showcase","summary":"","title":"Blowfish Lowkey - Repo"},{"content":"","date":"6 November 2020","permalink":"/examples/blowfish-template/","section":"Showcase","summary":"","title":"Blowfish Template"},{"content":"","date":"6 November 2020","permalink":"/examples/blowfish-template-repo/","section":"Showcase","summary":"","title":"Blowfish Template - GitHub Repo"},{"content":"按照星期维度统计学习计划\n上周review # leetcode 15 but 3 litter prince chapter 1 not execute 提升忍耐力 目标 # keyword: 机器人，忍耐力提升\nenglish .chapter 1 chapter 2 90+ work langchain uml code leetcode 15 health 八段锦 every night animal flow begin run 20220918 # leetcode 3 八段锦 night and animal flow english chapter 1 succeed review\nachieve 2. review 3 run 3km replace 八段锦 read english. 15/37 9,13,14,17,18,19,21,22,23,24,25,27,29,30,31,33,34,35,36,37 20220919 # leetcode 3 read english . 25/37 八段锦 night and animal flow review\nachieve leetcode 3 read english 27/37 no fitness 20220920 # leetcode 3 分析单词 八段锦 langchain学习。分析十个人物 module type: implement， abstract， fix bug\u0026hellip; user graph ","date":"18 September 2020","permalink":"/business/0918/","section":"project","summary":"按照星期维度统计学习计划\n上周review # leetcode 15 but 3 litter prince chapter 1 not execute 提升忍耐力 目标 # keyword: 机器人，忍耐力提升\nenglish .chapter 1 chapter 2 90+ work langchain uml code leetcode 15 health 八段锦 every night animal flow begin run 20220918 # leetcode 3 八段锦 night and animal flow english chapter 1 succeed review","title":"20220918-20220924"},{"content":"","date":"18 September 2020","permalink":"/tags/langchain/","section":"Tags","summary":"","title":"langchain"},{"content":" Project # file # init.py # 展示层入口\nagents MRKLChain ReActChain SelfAskWithSearchChain chains ConversationChain LLMBashChain LLMChain LLMCheckerChain LLMMathChain QAWithSourcesChain VectorDBQA VectorDBQAWithSourcesChain docstore InMemoryDocstore Wikipedia llms Anthropic Banana CerebriumAI Cohere ForefrontAI GooseAI HuggingFaceHub HuggingFaceTextGenInference LlamaCpp Model OpenAI Petals PipeLineAI SagemakerEndpoint StochasticAI Writer schema cashe prompt utilities golden_query google_search powerbi searx_search serpapi sql_database wikipedia wolfram_alphs concept # Agents tool: tool to get potential info think: ai to think\nRetrieval\nMany LLM applications require user-specific data that is not part of the model\u0026rsquo;s training set Chains\ninput output callback Entity # Cache # Cache loopup update clear Agents # AgentAction\ntool tool_input log AgentFinish\nreturn_values log Retrieval # Document\npage_content: str metadata: dict = Field(default_factory=dict) BaseDocumentTransformer(data connect source)\ntransform_documents(self, documents: Sequence[Document], **kwargs: Any) BaseMemory\nmemory_variables load_memory_variables save_context clear BaseChatMessageHistory\nadd_user_message add_ai_message add_message clear BaseRetriever\ninvoke get_relevant_documents BaseStore\nChains # BaseLanguageModel generate_prompt(self,prompts: List[PromptValue],stop: Optional[List[str]] = None, callbacks: Callbacks = None,**kwargs: Any,) # stop: Stop words to use when generating. Model output is cut off at the first occurrence of any of these substrings. predict(self, text: str, *, stop: Optional[Sequence[str]] = None, **kwargs: Any) get_token_ids(self, text: str) -\u0026gt; List[int] get_num_tokens(self, text: str) -\u0026gt; int get_num_tokens_from_messages(self, messages: List[BaseMessage]) -\u0026gt; int _all_required_field_names(cls) -\u0026gt; Set BaseMessage(Serializable) # model input or output BaseMessageChunk Generation(Serializable) BaseLLMOutputParser(Serializable) PromptValue(Serializable) 和文档对应，主要看三个模块，agents， retrievals， chains\nRelation # Other # ","date":"18 September 2020","permalink":"/business/langchain/","section":"project","summary":"Project # file # init.py # 展示层入口\nagents MRKLChain ReActChain SelfAskWithSearchChain chains ConversationChain LLMBashChain LLMChain LLMCheckerChain LLMMathChain QAWithSourcesChain VectorDBQA VectorDBQAWithSourcesChain docstore InMemoryDocstore Wikipedia llms Anthropic Banana CerebriumAI Cohere ForefrontAI GooseAI HuggingFaceHub HuggingFaceTextGenInference LlamaCpp Model OpenAI Petals PipeLineAI SagemakerEndpoint StochasticAI Writer schema cashe prompt utilities golden_query google_search powerbi searx_search serpapi sql_database wikipedia wolfram_alphs concept # Agents tool: tool to get potential info think: ai to think","title":"langchain 学习"},{"content":"按照星期维度统计学习计划\n目标 # I want to read litter prince in english, I think when I read in youtube or some other place, I become litter prince. I want to prove my ability in work, I can create, I can achieve a project very well. But I want to know what I want to do, maybe ai, maybe web3, maybe react, maybe make money in upwork, I must check it in this work. I want to write leetcode to improve my code skill. Every week I at least write 10 leetcode. maybe I want to know how to write a good code. I want to have a good health, I can do 八段锦 20230912 # 第一节全文听懂 能够准确地说，每句话每个单词 验证upwork是否可以找到付费项目（x） 验证figma是否能找到付费项目 （x） 拓展网站 （x） 实现自动化获取信息 （x） review # 第一节听完了，完成 验证全部失败需要重新整理 开始基于uml重新梳理代码，目前计划结合ai看看有没有什么机会 工作需要继续，今天要把爬虫作完 20230913 # [fluency] 1 -\u0026gt; chapter 1 achieve， target is 80+ [fluency] 3 -\u0026gt; langchain uml in lucid [come] 2 -\u0026gt; boss crawler in github [come] 2 -\u0026gt; find go-langchain, maybe I can write it, yes or no [think] 2 -\u0026gt; think how to find a project in node review # working 20230914 # [fluency] 1 -\u0026gt; chapter 1 achieve， target is 80+ [fluency] 3 -\u0026gt; langchain uml in lucid [come] 2 -\u0026gt; find go-langchain, maybe I can write it, yes or no [think] 2 -\u0026gt; think how to find a project in node review # 今天还是在工作，基本上写完了，每次完成一个项目就很难过 发现langchain有golang版本~ ","date":"12 September 2020","permalink":"/business/0912/","section":"project","summary":"按照星期维度统计学习计划\n目标 # I want to read litter prince in english, I think when I read in youtube or some other place, I become litter prince. I want to prove my ability in work, I can create, I can achieve a project very well.","title":"week work"},{"content":"","date":"11 September 2020","permalink":"/tags/pmp/","section":"Tags","summary":"","title":"pmp"},{"content":"","date":"11 September 2020","permalink":"/tags/uml/","section":"Tags","summary":"","title":"uml"},{"content":" UML作用 # 用于软件开发的可视化建模语言 高效软件流程入口 Use Case # actor interact with your system input: 需求 actor # 用人物图标表示 who is actor # 软件使用人员 其他系统 actor inspect # 对于用户的角度来说，输入对应的输入以获取输出 interact \u0026amp;\u0026amp; communication # use case 用椭圆和文字表示 直线表示链接 what is good # can measurable result can simple test relation # include: reuse extend: if , 判断条件 system # 用方框表示 class # visibility # public + private - attributes # 要么在框框里面 要么在注释或者链接上面 Behavior # 函数描述行为 static # 单例模式功能相同 下面画横线 relationship # Dependency: 仅仅表示之间有关系 Association：contain a reference to an object Aggregation：own这个类但是这个类可能共享到其他class Composition: 这个类只用来组合，不能共享 Inheritance: 继承 Constraints # Invariants：限制，变量限制 Preconditions:前置条件 Postconditions: 后置条件 Abstract Classes # italics , 斜体 interface # ","date":"11 September 2020","permalink":"/business/uml/","section":"project","summary":" UML作用 # 用于软件开发的可视化建模语言 高效软件流程入口 Use Case # actor interact with your system input: 需求 actor # 用人物图标表示 who is actor # 软件使用人员 其他系统 actor inspect # 对于用户的角度来说，输入对应的输入以获取输出 interact \u0026amp;\u0026amp; communication # use case 用椭圆和文字表示 直线表示链接 what is good # can measurable result can simple test relation # include: reuse extend: if , 判断条件 system # 用方框表示 class # visibility # public + private - attributes # 要么在框框里面 要么在注释或者链接上面 Behavior # 函数描述行为 static # 单例模式功能相同 下面画横线 relationship # Dependency: 仅仅表示之间有关系 Association：contain a reference to an object Aggregation：own这个类但是这个类可能共享到其他class Composition: 这个类只用来组合，不能共享 Inheritance: 继承 Constraints # Invariants：限制，变量限制 Preconditions:前置条件 Postconditions: 后置条件 Abstract Classes # italics , 斜体 interface # ","title":"UML"},{"content":"","date":"14 August 2020","permalink":"/tags/sample/","section":"Tags","summary":"","title":"sample"},{"content":"","date":"14 August 2020","permalink":"/tags/users/","section":"Tags","summary":"","title":"users"},{"content":"Real websites that are built with Blowfish. Check the full list in JSON format.\nBlowfish user? To add your site to this list, submit a pull request. ","date":"14 August 2020","permalink":"/users/","section":"Users","summary":"Real websites that are built with Blowfish. Check the full list in JSON format.\nBlowfish user? To add your site to this list, submit a pull request. ","title":"Users"},{"content":" question # 论文\nAI如何基于图构建思维链，我们已经知道了langchain 如何切入到指标生产中，提高我的精度 名词 # few-shot / zero shot : 一些例子，或者没有例子 Self-Consistency with CoT 精度提升 # we enable a fine-grained control over individual thoughts，更细粒度的控制 ","date":"9 August 2020","permalink":"/business/meta-gpt/","section":"project","summary":" question # 论文\nAI如何基于图构建思维链，我们已经知道了langchain 如何切入到指标生产中，提高我的精度 名词 # few-shot / zero shot : 一些例子，或者没有例子 Self-Consistency with CoT 精度提升 # we enable a fine-grained control over individual thoughts，更细粒度的控制 ","title":"MetaGPT项目学习"},{"content":" MetaGPT\n核心 # 抽象企业\n容易接受。本质是AI在抽象能力的利用，我之前有想法在指标计算流程上，使用这套方式进行，在思路上不如这个容易接受。不过指标计算上，更容易落地，所以还是我没做出来 案例分析 # mock 今日头条企业 # 输入： python startup.py \u0026quot;Design a RecSys like Toutiao\u0026quot; 输出： api design， orm 图 输出不够直观，app \u0026gt; api \u0026gt; termina 如何实现 # hello world # provider: 提供claude2， claude和chatgpt， openai api的接口实现 research 角色实现 # 角色划分 # 架构师（Architect） 项目管理（ProjectManager） 工程师（Engineer） 质检工程师（QaEngineer） 研究者（Searcher） 销售（sale） 客服（CustomerService） 角色定义 name: str profile: str goal: str constraints: str desc: str 角色行文 只有一层 问题：你需要回答的输入问题 思考：你应该始终思考该怎么做 行动：要采取的行动，应该是[{tool_names}]中的一个 行动输入：行动的输入 观察：行动的结果,这里主要指获取结果 ...（这个思考/行动/行动输入/观察可以重复N次） 思考：我现在知道最终答案了 最终答案：对原始输入问题的最终答案 search google # 行动\nSearchAndSummarize 总结 # 应该不怎么精准 建模很棒，企业模型以及事件处理模型 基于指标建模，可以使用 ","date":"9 August 2020","permalink":"/business/meta-gpt/","section":"project","summary":"MetaGPT\n核心 # 抽象企业\n容易接受。本质是AI在抽象能力的利用，我之前有想法在指标计算流程上，使用这套方式进行，在思路上不如这个容易接受。不过指标计算上，更容易落地，所以还是我没做出来 案例分析 # mock 今日头条企业 # 输入： python startup.py \u0026quot;Design a RecSys like Toutiao\u0026quot; 输出： api design， orm 图 输出不够直观，app \u0026gt; api \u0026gt; termina 如何实现 # hello world # provider: 提供claude2， claude和chatgpt， openai api的接口实现 research 角色实现 # 角色划分 # 架构师（Architect） 项目管理（ProjectManager） 工程师（Engineer） 质检工程师（QaEngineer） 研究者（Searcher） 销售（sale） 客服（CustomerService） 角色定义 name: str profile: str goal: str constraints: str desc: str 角色行文 只有一层 问题：你需要回答的输入问题 思考：你应该始终思考该怎么做 行动：要采取的行动，应该是[{tool_names}]中的一个 行动输入：行动的输入 观察：行动的结果,这里主要指获取结果 .","title":"MetaGPT项目学习"},{"content":"This is the advanced tag. Just like other listing pages in Blowfish, you can add custom content to individual taxonomy terms and it will be displayed at the top of the term listing. 🚀\nYou can also use these content pages to define Hugo metadata like titles and descriptions that will be used for SEO and other purposes.\n","date":"1 January 0001","permalink":"/tags/advanced/","section":"Tags","summary":"This is the advanced tag. Just like other listing pages in Blowfish, you can add custom content to individual taxonomy terms and it will be displayed at the top of the term listing.","title":"Advanced"},{"content":"A quick example of how to start using author taxonomies in your articles.\n","date":"1 January 0001","permalink":"/authors/","section":"Authors Taxonomy Listing Example","summary":"A quick example of how to start using author taxonomies in your articles.","title":"Authors Taxonomy Listing Example"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":" Hello ","date":"1 January 0001","permalink":"/docs/","section":"Documentation","summary":" Hello ","title":"Documentation"},{"content":"Dummy Second Author\u0026rsquo;s awesome dummy bio.\n","date":"1 January 0001","permalink":"/authors/secondauthor/","section":"Authors Taxonomy Listing Example","summary":"Dummy Second Author\u0026rsquo;s awesome dummy bio.","title":"Dummy Second Author"},{"content":"Nuno\u0026rsquo;s awesome dummy bio.\n","date":"1 January 0001","permalink":"/authors/nunocoracao/","section":"Authors Taxonomy Listing Example","summary":"Nuno\u0026rsquo;s awesome dummy bio.","title":"Nuno Coração"},{"content":" think ai google ai 现状分析 经济学 交易\n孙子兵法 通向金融王国的自由之路 以交易为生 股票作手回忆录 贫穷的本质 ","date":"1 January 0001","permalink":"/todo/","section":"TODO list","summary":" think ai google ai 现状分析 经济学 交易\n孙子兵法 通向金融王国的自由之路 以交易为生 股票作手回忆录 贫穷的本质 ","title":"TODO list"}]