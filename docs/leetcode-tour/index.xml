<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LeetCode Tour on WithME</title><link>https://xiaokuili.github.io/leetcode-tour/</link><description>Recent content in LeetCode Tour on WithME</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>© 2023 WithME</copyright><lastBuildDate>Tue, 29 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://xiaokuili.github.io/leetcode-tour/index.xml" rel="self" type="application/rss+xml"/><item><title>列表</title><link>https://xiaokuili.github.io/leetcode-tour/list/</link><pubDate>Tue, 29 Aug 2023 00:00:00 +0000</pubDate><guid>https://xiaokuili.github.io/leetcode-tour/list/</guid><description>静态Arrays # array用来连续存储数据。在严格类型语言例如java，c++， c#等，arrays初始化必须声明大小。这就意味着，列表大小一旦声明不能改变，如果容量到达，不可以再存储。弱语言类型例如Python和Javascript没有静态Array，我们下一个章节讨论
让我们学习array对应的操作，他们有效并且有用。最常用的操作是
Reading Deletion Insertion Reading # # initialize myArray myArray = [1,3,5] # access an element, where i is the index of the desired value myArray[i] 只要通过index访问元素，时间复杂度就是常量。这是因为每一个myArray的index被映射到一个RAM的address 。这是一个单一的操作，在语法分析中我们称为O(1).</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://xiaokuili.github.io/leetcode-tour/list/featured.png"/></item><item><title>链表</title><link>https://xiaokuili.github.io/leetcode-tour/link/</link><pubDate>Sun, 27 Aug 2023 00:00:00 +0000</pubDate><guid>https://xiaokuili.github.io/leetcode-tour/link/</guid><description>单向链表 # 链表是另一个数据结构，像列表一样顺序存储元素在，但是也有不同。
第一个不同是，链表通过ListNode对象组成，这个对象包含两个属性：
value - 存储节点值，value可以是任何，character，int 等 next - 存储链表中下一个节点。这个图是ListNode对象的可视化。 创建链表 # 初始化 # 链表是串联ListNode对象在一起。下面是创建你自己的ListNode类的伪代码
class ListNode: constructor (value, next): 1. Set value to the desired value, i.e. integer, char, etc.</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://xiaokuili.github.io/leetcode-tour/link/featured.png"/></item><item><title>优先级队列</title><link>https://xiaokuili.github.io/leetcode-tour/queue/</link><pubDate>Sat, 26 Aug 2023 00:00:00 +0000</pubDate><guid>https://xiaokuili.github.io/leetcode-tour/queue/</guid><description>队列 # 队列和堆栈相似，除了队列遵守先进先出。一个真实世界的例子是银行排队。第一个去排队的人第一个受到服务。一个软件世界的例子是打印。例如，如果多个人尽量去打印文档，第一个来的人将先被处理。
实现和操作 # 最普通的队列实现是使用一个链表
队列支持两个操作 enqueue 和 dequeue
入队 # 添加元素到队列尾， 直到队列满了。由于添加对尾不需要移动元素，所以时间复杂度是O(1)
def enqueue(self, val): newNode = ListNode(val) # Queue is non-empty if self.right: self.right.next = newNode self.</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://xiaokuili.github.io/leetcode-tour/queue/featured.png"/></item><item><title>哈希</title><link>https://xiaokuili.github.io/leetcode-tour/hash/</link><pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate><guid>https://xiaokuili.github.io/leetcode-tour/hash/</guid><description>我们已经谈论过TreeSet和TreeMaps在先前的章节，让我们讨论，如何使用hashing实现map和set。在这个章节，我们将聚焦在使用HashSet和HashMap.
当提到唯一，数量，频率就想到hash。面试一般不会专门考察
时间复杂度 # Operation TreeMap HashMap Array Insert O(log n) O(1) O(n) Remove O(log n) O(1) O(n) Search O(log n) O(1) O(log n) Inorder Traversal O(n) hash map 作用 # hashmap的副作用，存储没有顺序，如果想遍历所有的key需要O(nlogn)时间复杂度</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://xiaokuili.github.io/leetcode-tour/hash/featured.png"/></item><item><title>递归</title><link>https://xiaokuili.github.io/leetcode-tour/recursion/</link><pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate><guid>https://xiaokuili.github.io/leetcode-tour/recursion/</guid><description>One Branch # 递归是一个比较容易绊住脑子的问题，所以如果没有直接理解，也不要泄气
递归是，函数调用自己，并且产生相同的输出。同时也可以基于迭代函数可以通过while或者for来实现循环。 基础条件 函数调用自身 让我们计算n的阶乘， 这个公式是，n! = n*(n-1)*(n-2)..*1，等价于 n! = n * (n-1)!
function factorial(n) { if (n &amp;lt;= 1) { return 1; } return n * factorial(n - 1); } // example , 线性递归 5!</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://xiaokuili.github.io/leetcode-tour/recursion/featured.png"/></item><item><title>排序</title><link>https://xiaokuili.github.io/leetcode-tour/sort/</link><pubDate>Wed, 23 Aug 2023 00:00:00 +0000</pubDate><guid>https://xiaokuili.github.io/leetcode-tour/sort/</guid><description>插入排序 # 插入排序是一个排序算法。是最简单的排序算法，很适合数据量很小的时候使用
概念 # 将元素插入到已经排序好的列表中 [2,3,4,1,6]这个列表。我们将2看做已经排序的列表，将3拿出来，插入到2后面。之后将2，3看做已经排序的列表，将4拿出来插入到2, 3中，直到结束
j代表已经排序的列表最后一个值的指针。j+1就是下一个待排数据 待排数据与已排列表的进行冒泡排序，比如1要排入[2,3,4], 1和4交换，变成[2,3,1,4],1在和3交换变成[2,1,3,4] function insertionSort(arr) { for (let i = 1; i &amp;lt; arr.length; i++) { let j = i - 1; while (j &amp;gt;= 0 &amp;amp;&amp;amp; arr[j+1] &amp;lt; arr[j]) { let tmp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = tmp; j--; } } return arr; } 时间复杂度 # o(n)</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://xiaokuili.github.io/leetcode-tour/sort/featured.png"/></item><item><title>查找</title><link>https://xiaokuili.github.io/leetcode-tour/search/</link><pubDate>Tue, 22 Aug 2023 00:00:00 +0000</pubDate><guid>https://xiaokuili.github.io/leetcode-tour/search/</guid><description>二差查找 # 二差查找是一个有效的方式，在一个排序列表中查询元素。
他的核心是，二差查找在中间分隔列表，这个点叫mid，并且比较目标值和mid值。如果mid的值比目标值更小，淘汰掉左半部分和查找mid的右半部分。如果mid 比目标目标值更大，我们查找左部分。我们要么发现目标值，或者决定目标值不存在。
在面试和算法问题中，通常有两种类型的二叉搜索问题：
Search Array-一个排序列表，目标被给定和目标是确定目标是否在列表中 Search Range-一个范围被给，没有特别指定目标 二叉搜索的机制 # 目标值被给作为输入，但是我们需要计算mid 。mid被初始化通过最左边和最右边的索引值相加除2。这允许我们有两个相等的列表，在二叉查找中，我们需要有以下部分
L - 目前子列表最左边 R -目前列表最右边 mid - L+R/2 通过这个节点分隔列表成两部分 我们目前搜索target的结果知道要么我们找到target，或者L指针大于R指针，代表target不存在
Target 存在在array, 返回 # 让我们讨论上面的概念和举例子。拿这个array arr=[1,2,3,4,5,6,7,8], 5是我们的目标</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://xiaokuili.github.io/leetcode-tour/search/featured.png"/></item><item><title>树</title><link>https://xiaokuili.github.io/leetcode-tour/tree/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://xiaokuili.github.io/leetcode-tour/tree/</guid><description>属性 # 根节点 # 跟节点是树中最高的节点，没有父节点。在树中所有的节点可以到达根节点。
叶子节点 # 叶子节点是没有孩子的节点。最后一层担保出现叶子节点，但是他也可以出现在其他层 孩子 # 孩子节点是这个节点的左节点和右节点
高度 # 二叉树的高度是说从根节点到叶子节点。单一节点高度为1
另外，就像列表从0开始，这里的高度也可能从0开始
深度 # 深度是指，这个节点到根节点 all zhe way up。应该是经历的节点个数
祖先 # 链接到这个节点下面的所有的节点，认为这个节点是祖先
子孙 # 子孙是一个节点的孩子或者是孩子的孩子
二叉树 # 二叉树是另一个数据结构，卷入了节点和指针。我们谈论了指针在链表的章节。我们通过next和prev指针链接节点。在二叉树中的节点也有两个指针，但是我们叫他们左指针和右指针。二叉树的第一个节点被称为跟节点。我们通过一条线代表节点。</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://xiaokuili.github.io/leetcode-tour/tree/featured.png"/></item><item><title>回朔</title><link>https://xiaokuili.github.io/leetcode-tour/backtrack/</link><pubDate>Sun, 20 Aug 2023 00:00:00 +0000</pubDate><guid>https://xiaokuili.github.io/leetcode-tour/backtrack/</guid><description>回朔是一个算法，类似于我们之前讨论的二叉树深度优先算法。它通过暴力的方式解决，想象我们需要寻找图片锁的所有解决方式。我们不得不做一个过渡的查询发现所有组合的可能。这不是一个好的算法，拿到所有的组合，并且一个个的遍历所有组合。有一种回朔的方式，我们探索一种可能的方式去解决问题，如果我们没有成功，我们回去和探索其他的方式直到我们解决了问题
例子 # 我们已经直接讨论过，回朔是什么，和讨论了DFS。让我们看一下如何解决下面的问题
💡 判断一个路径是否存在，从跟节点到叶子节点， 并且不包含任何0节点 这个问题是在问我们，如果我们从跟节点到叶子节点遍历，如果不包含0，我们返回True， 否则， False
首先想到的是使用深度优先算法， 我们限制是，我们不能有0的节点。我们也知道，如果树是空的，我们不会存在一个有效的路径。最终，如果我们到达叶子节点，并且没有返回false，我们可以返回true。
我们假设这个问题，存在这样一条路径，要么在左边，要么在右边。我们先查询左边，如果没有发现，查询右边，如果存在，返回True
给定这个树，[4,0,1,null,7,2,0] ,路径如图所示。
class TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None def canReachLeaf(root): if not root or root.</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://xiaokuili.github.io/leetcode-tour/backtrack/featured.png"/></item><item><title>图</title><link>https://xiaokuili.github.io/leetcode-tour/graph/</link><pubDate>Sat, 19 Aug 2023 00:00:00 +0000</pubDate><guid>https://xiaokuili.github.io/leetcode-tour/graph/</guid><description>我们在这个课程中已经遭遇了图多次。一个图是节点和指针构造的数据结构
让我们了解一些图的术语首先
图术语 # 在图中，节点被当作定点和指针链接被当作边。节点位置和边链接也没有限制。
也有可能，节点没有被任何边链接和这里仍然可以被当作图，一个空的图。
如果图的边有方向，我们叫做有向图，没有没有方向，我们叫做无向图
图算法面试 # 图可以被不同数据结构代表。他是一个抽象的概念，一般被下面三种数据结构代表
矩阵 邻接矩阵 邻接列表 矩阵 # 一个矩阵是一个带有行和列二维数组，图可以被矩阵代表。在下面的代码中，每一个列表，被逗号分隔，代表每一个行。我们有4行或者4列。从0开始，进入第二行可以通过gird[1]和进入第二列可以通过gird[0][1]
如何用它来表示图形？正如我们提到的，图是抽象的，可以通过多种方式定义。假设网格中的所有 0 都是顶点。为了遍历一个图，我们可以向上、向下、向左、向右移动。如果我们要使用边缘将 0 连接在一起，我们最终会得到一堆连接的零，它们是连接的组件，表示一个图。我们将在下一章讨论矩阵遍历。
真的用矩阵代表图，就是字面意思 0 代表可以通过，1代表不可以通过 邻接矩阵 # 在是一个不太寻常的表示方式，这里的索引代表定点本身
adjMatrix = [[0, 0, 0, 0], [1, 1, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]] 因为索引本身代表一个顶点，0代表一个边不存在在给定的索引v1，v2 ，1代表相反。adjMatrix[1][2] == 0 意味着这里没有边在1和2之间。</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://xiaokuili.github.io/leetcode-tour/graph/featured.png"/></item><item><title>动态规划</title><link>https://xiaokuili.github.io/leetcode-tour/dp/</link><pubDate>Fri, 18 Aug 2023 00:00:00 +0000</pubDate><guid>https://xiaokuili.github.io/leetcode-tour/dp/</guid><description>让我们现在讨论grid并且找到我们如何通过动态规划处理他。让我们解决下面的问题，和我们图遇到的问题详细
计算从左上角到右下角唯一路径。你只可以右移和下移动
让我们带入下面的grid到讨论中，我们只允许右移和下移。边界是，r大于row和c大于col
暴力法 # 暴力的手段，从0，0，如图所示，箭头代表当前点可以移动的方向。计算给顶点到目的地的唯一节点，我们仅仅将返回值添加到当前坐标上。下图展示蛮力的方法，但是可以看到他的局限性。
# Brute Force - Time: O(2 ^ (n + m)), Space: O(n + m) def bruteForce(r, c, rows, cols): if r == rows or c == cols: return 0 if r == rows - 1 and c == cols - 1: return 1 return (bruteForce(r + 1, c, rows, cols) + bruteForce(r, c + 1, rows, cols)) 问题 # 这个问题是我们不得不计算一个极点很多次，尤其适用从上到校。</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://xiaokuili.github.io/leetcode-tour/dp/featured.png"/></item><item><title>题目</title><link>https://xiaokuili.github.io/leetcode-tour/shortcodes/</link><pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate><guid>https://xiaokuili.github.io/leetcode-tour/shortcodes/</guid><description> 题目 # 视频讲解
题号 题目 标签 26 Remove Duplicates from Sorted Array 列表 27 Remove Element 列表 682 Baseball Game 列表 20 Valid Parentheses 列表 155 Min Stack 列表 206 Reverse Linked List 递归,链表 21 Merge Two Sorted Lists 链表 707 Design Linked List 链表 1472 Design Browser History 链表 1700 Number of Students Unable to Eat Lunch 链表 509 Fibonacci Number 递归 70 Climbing Stairs 动态规划,递归 23 Merge k Sorted Lists 排序 215 Kth Largest Element in an Array 排序 75 Sort Colors 排序 912 Sort an Array 排序 704 Binary Search 查找 74 Search a 2D Matrix 查找 374 Guess Number Higher or Lower 查找 278 First Bad Version 查找 875 Koko Eating Bananas 查找 700 Search in a Binary Search Tree 树 701 Insert into a Binary Search Tree 树 450 Delete Node in a BST 树 94 Binary Tree Inorder Traversal 树 230 Kth Smallest Element in a BST 树 102 Binary Tree Level Order Traversal 树 199 Binary Tree Right Side View 树 112 Path Sum 回朔 78 Subsets 回朔 39 Combination Sum 回朔 703 Kth Largest Element in a Stream 优先级队列 1046 Last Stone Weight 优先级队列 973 K Closest Points to Origin 优先级队列 217 Contains Duplicate hash 1 Two Sum hash 146 LRU Cache hash 200 Number of Islands 图 695 Max Area of Island 图 1091 Shortest Path in Binary Matrix 图 994 Rotting Oranges 图 133 Clone Graph 图 198 House Robber 动态规划 63 Unique Paths II 动态规划 62 Unique Paths 动态规划 1143 Longest Common Subsequence 动态规划</description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://xiaokuili.github.io/leetcode-tour/shortcodes/featured.png"/></item></channel></rss>